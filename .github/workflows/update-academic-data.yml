name: Update Academic Data

on:
  schedule:
    # æ¯ä¸ªå·¥ä½œæ—¥ï¼ˆå‘¨ä¸€è‡³å‘¨äº”ï¼‰åŒ—äº¬æ—¶é—´æ—©ä¸Š8:00è¿è¡Œï¼ˆUTCæ—¶é—´0:00ï¼‰
    - cron: '0 0 * * 1-5'
  # å…è®¸æ‰‹åŠ¨è§¦å‘
  workflow_dispatch:

jobs:
  update-data:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      # å¢åŠ æ¨¡å‹ç¼“å­˜æ­¥éª¤
      - name: Cache Hugging Face models
        uses: actions/cache@v4
        with:
          path: ./.cache/huggingface/hub  # å°†å°†ç¼“å­˜è·¯å¾„æŒ‡å®šä¸ºé¡¹ç›®å·¥ä½œåŒºå†…çš„ä¸€ä¸ªæ˜ç¡®ç›®å½•
          key: ${{ runner.os }}-transformers-cache-v3 #  æ›´æ–°keyçš„ç‰ˆæœ¬å·ä»¥ç¡®ä¿ä½¿ç”¨æ–°è·¯å¾„

      - name: Install dependencies
        run: npm install node-fetch@2 dotenv @xenova/transformers hnswlib-node fast-xml-parser

      - name: Create updater script
        run: |
          cat > update-data.js << 'EOL'
          // ... æ­¤å¤„çœç•¥ update-data.js çš„å®Œæ•´å†…å®¹ï¼Œä¸æ‚¨ä¸Šä¸€ç‰ˆæœ¬ç›¸åŒ ...
          // ... è¯·ç¡®ä¿è¿™é‡Œæ˜¯æ‚¨æœ€æ–°çš„ã€æ— æ ¼å¼é”™è¯¯ã€ä¸”åŒ…å«æ‰€æœ‰æ–°é€»è¾‘çš„è„šæœ¬ ...
          EOL

      - name: Install dependencies
        run: npm install node-fetch@2 dotenv @xenova/transformers hnswlib-node fast-xml-parser

      - name: Create updater script
        run: |
          cat > update-data.js << 'EOL'
          // ---ã€ä¿®æ­£ç‚¹1ã€‘---: æ¨¡å—åŠ è½½æ–¹å¼ç»Ÿä¸€ä¿®æ­£
          require('dotenv').config();
          const fetch = require('node-fetch');
          const { HierarchicalNSW } = require('hnswlib-node');

          // --- é…ç½® ---
          const DEBUG_MODE = false; // æ­£å¼è¿è¡Œæ—¶è¯·è®¾ä¸º false
          
          const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
          const GITHUB_REPO = process.env.GITHUB_REPOSITORY;
          const PERPLEXITY_API_KEY = process.env.PERPLEXITY_API_KEY;
          
          const DATA_FILE = 'academic_data.json';
          const KEYWORD_HISTORY_FILE = 'daily_keyword_history.json';
          const FULL_KEYWORDS_FILE = 'keywords_full.json';
          const PROCESSED_URLS_FILE = 'processed_urls.json';

          const STAGING_AREA_LIMIT = 50;
          const TOP_N_TO_PROCESS = 6;
          const MAX_PAPERS_TO_KEEP = 100;
          const KEYWORD_HISTORY_WINDOW = 15;

          const DEFAULT_KEYWORDS = ["é€šä¿¡", "AI 6G", "Agent", "LLM", "è¯­ä¹‰é€šä¿¡"];
          const KEYWORDS_ENGLISH_MAPPING = { "é€šä¿¡": "Communications", "AI 6G": "AI 6G", "Agent": "Agent", "LLM": "Large Language Model", "è¯­ä¹‰é€šä¿¡": "Semantic Communications" };
          const EMBEDDING_MODEL = 'Xenova/all-MiniLM-L6-v2';
          const VECTOR_DIMENSIONS = 384;

          // --- æ ¸å¿ƒå·¥å…·å‡½æ•° ---
          async function fetchJsonFile(fileName, defaultValue = null) {
            try {
              const url = `https://api.github.com/repos/${GITHUB_REPO}/contents/${fileName}`;
              const headers = { 'Authorization': `token ${GITHUB_TOKEN}` };
              const response = await fetch(url, { headers });
              if (!response.ok) {
                if (response.status === 404) { console.log(`æ–‡ä»¶ ${fileName} æœªæ‰¾åˆ°ï¼Œå°†ä½¿ç”¨é»˜è®¤å€¼ã€‚`); return { content: defaultValue, sha: null }; }
                throw new Error(`GitHub API error for ${fileName}: ${response.status}`);
              }
              const data = await response.json();
              const content = Buffer.from(data.content, 'base64').toString('utf8');
              console.log(`âœ… æˆåŠŸè·å–æ–‡ä»¶ ${fileName}`);
              return { content: JSON.parse(content), sha: data.sha };
            } catch (error) {
              console.error(`è·å–æ–‡ä»¶ ${fileName} æ—¶å‡ºé”™:`, error.message);
              return { content: defaultValue, sha: null };
            }
          }

          async function saveJsonFile(fileName, data, sha) {
            try {
              const url = `https://api.github.com/repos/${GITHUB_REPO}/contents/${fileName}`;
              const headers = { 'Authorization': `token ${GITHUB_TOKEN}`, 'Content-Type': 'application/json' };
              const content = JSON.stringify(data, null, 2);
              const encodedContent = Buffer.from(content).toString('base64');
              const body = { message: `æ›´æ–°æ•°æ®æ–‡ä»¶: ${fileName}`, content: encodedContent, branch: 'main' };
              if (sha) body.sha = sha;
              const response = await fetch(url, { method: 'PUT', headers, body: JSON.stringify(body) });
              if (!response.ok) { const errorText = await response.text(); throw new Error(`ä¿å­˜åˆ°GitHubæ–‡ä»¶ ${fileName} å¤±è´¥ (${response.status}): ${errorText}`); } // ã€ä¿®æ­£ç‚¹1ã€‘
              console.log(`âœ… æˆåŠŸä¿å­˜æ–‡ä»¶åˆ° ${fileName}`);
            } catch (error) {
              console.error(`ä¿å­˜æ–‡ä»¶ ${fileName} æ—¶å‡ºé”™:`, error);
              throw error;
            }
          }
          
          // ---ã€ä¿®æ­£ç‚¹2ã€‘---: ä¿®æ­£ queryPerplexityAndParseJson å‡½æ•°
          async function queryPerplexityAndParseJson(prompt) {
              try {
                  if (!PERPLEXITY_API_KEY) throw new Error("Perplexity API key is missing");
                  const url = "https://api.perplexity.ai/chat/completions";
                  const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${PERPLEXITY_API_KEY}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: "sonar-pro", messages: [{ role: "user", content: prompt }] }) // ä½¿ç”¨ä¼ å…¥çš„ prompt
                  });
                  if (!response.ok) { const errorText = await response.text(); throw new Error(`Perplexity API error (${response.status}): ${errorText}`);}
                  const result = await response.json(); // ç›´æ¥ä½¿ç”¨ response.json()
                  const content = result.choices[0].message.content;
                  const jsonMatch = content.match(/\{[\s\S]*\}/);
                  if (jsonMatch) return JSON.parse(jsonMatch[0]);
                  return null;
              } catch (e) {
                  console.error("è§£æPerplexityè¿”å›çš„JSONæ—¶å‡ºé”™:", e);
                  return null;
              }
          }

          // --- æ‹‰å–â€œå¤§åº“â€å‡½æ•° ---
          async function fetchStagingPapers(limit = STAGING_AREA_LIMIT, maxRetries = 3) {
            const { XMLParser } = await import('fast-xml-parser');
            const coreTopicsQuery = '((all:"AI" AND all:"6G") OR all:"Semantic Communication")';
            const crossTopics = ["Agent", "Memory Management"];
            const crossTopicsQuery = crossTopics.map(t => `all:"${t}"`).join(' OR ');
            // const now = new Date();
            // const threeMonthsAgo = new Date();
            // threeMonthsAgo.setMonth(now.getMonth() - 1);
            // const formatDate = (date) => `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
            // const dateFilter = `submittedDate:[${formatDate(threeMonthsAgo)}0000 TO ${formatDate(now)}2359]`;

            // ---ã€ä¿®æ”¹ç‚¹ã€‘---: è°ƒæ•´æ—¥æœŸèŒƒå›´ä¸ºâ€œè¿‡å»24å°æ—¶â€
            const now = new Date();
            const yesterday = new Date();
            // 1. è®¡ç®—å‡º24å°æ—¶å‰çš„ç²¾ç¡®æ—¶é—´ç‚¹
            yesterday.setHours(now.getHours() - 24);

            // 2. åˆ›å»ºä¸€ä¸ªèƒ½æ ¼å¼åŒ–åˆ°åˆ†é’Ÿçš„å¸®åŠ©å‡½æ•°
            const formatDateTime = (date) => {
                const YYYY = date.getFullYear();
                const MM = (date.getMonth() + 1).toString().padStart(2, '0');
                const DD = date.getDate().toString().padStart(2, '0');
                const HH = date.getHours().toString().padStart(2, '0');
                const MIN = date.getMinutes().toString().padStart(2, '0');
                return `${YYYY}${MM}${DD}${HH}${MIN}`;
            };

            // 3. æ„å»ºç²¾ç¡®åˆ°åˆ†é’Ÿçš„æ—¥æœŸè¿‡æ»¤å™¨
            const dateFilter = `submittedDate:[${formatDateTime(yesterday)} TO ${formatDateTime(now)}]`;
            // --- ä¿®æ”¹ç»“æŸ ---

            // const searchQuery = `${coreTopicsQuery} AND (${crossTopicsQuery}) AND ${dateFilter}`;
            const searchQuery = `${coreTopicsQuery} AND ${dateFilter}`;
            const url = `http://export.arxiv.org/api/query?search_query=${encodeURIComponent(searchQuery)}&max_results=${limit}&sortBy=submittedDate&sortOrder=descending`;
            console.log(`å‘ arXiv API æŸ¥è¯¢ (è¯·æ±‚ ${limit} ç¯‡): ${searchQuery}`);
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url);
                    if (response.status !== 200) throw new Error(`API è¿”å›é”™è¯¯: ${response.status}`);
                    const xmlData = await response.text();
                    const parser = new XMLParser({ ignoreAttributes: false, attributeNamePrefix: "@_" });
                    const jsonData = parser.parse(xmlData);
                    if (!jsonData.feed || !jsonData.feed.entry) return [];
                    const entries = Array.isArray(jsonData.feed.entry) ? jsonData.feed.entry : [jsonData.feed.entry];
                    const papers = entries.map(entry => {
                        let authors = Array.isArray(entry.author) ? entry.author.map(a => a.name) : (entry.author ? [entry.author.name] : []);
                        const pdfLink = Array.isArray(entry.link) ? entry.link.find(l => l['@_title'] === 'pdf') : entry.link;
                        const paperId = pdfLink ? pdfLink['@_href'].split('/').pop().replace(/v\d+$/, '') : entry.id;
                        return { id: paperId, title: entry.title.replace(/\s+/g, ' ').trim(), url: entry.id, authors: authors, journal: 'arXiv', publicationDate: entry.published.split('T')[0], snippet: entry.summary.replace(/\s+/g, ' ').trim() };
                    });
                    console.log(`âœ… æˆåŠŸä» arXiv è·å–å¹¶è§£æäº† ${papers.length} ç¯‡è®ºæ–‡ã€‚`);
                    return papers;
                } catch (error) {
                    console.warn(`æŸ¥è¯¢ arXiv æ—¶å‡ºé”™ (ç¬¬ ${i + 1} æ¬¡å°è¯•):`, error.message);
                    if (i === maxRetries - 1) { console.error("å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ã€‚"); return []; }
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
            }
            return [];
          }

          // ---ã€ä¿®æ­£ç‚¹3ã€‘---: é‡æ„ä¸ºå•ç¯‡è®ºæ–‡ç²¾å¤„ç†å‡½æ•°
          async function analyzeSinglePaper(paper, embedder, memoryIndex, memoryContent) {
            console.log(`ğŸ¤” æ€è€ƒ: æ­£åœ¨ç²¾å¤„ç†è®ºæ–‡ "${paper.title}"`);
            
            // æ­¥éª¤ä¸€ï¼šè®ºæ–‡ç±»å‹åˆ†ç±»
            const classificationPrompt = `æ ¹æ®ä»¥ä¸‹è®ºæ–‡çš„æ ‡é¢˜å’Œæ‘˜è¦ï¼Œè¯·åˆ¤æ–­è¿™ç¯‡è®ºæ–‡æœ€æ¥è¿‘å“ªç§ç±»å‹ï¼Ÿåªéœ€ä» ["å®éªŒ/æ–¹æ³•å‹", "ç»¼è¿°/å›é¡¾å‹", "è§‚ç‚¹/ç«‹åœºå‹"] ä¸­é€‰æ‹©ä¸€ä¸ªè¿”å›ã€‚è¯·ä¸¥æ ¼æŒ‰ç…§JSONæ ¼å¼è¿”å›ï¼Œä¾‹å¦‚: {"paper_type": "å®éªŒ/æ–¹æ³•å‹"}\n\næ ‡é¢˜: ${paper.title}\næ‘˜è¦: ${paper.snippet}`;
            const classificationResult = await queryPerplexityAndParseJson(classificationPrompt);
            const paperType = classificationResult ? classificationResult.paper_type : "å®éªŒ/æ–¹æ³•å‹";
            console.log(`âœ… è®ºæ–‡ç±»å‹åˆ¤æ–­ä¸º: ${paperType}`);

            // æ­¥éª¤äºŒï¼šç›¸ä¼¼æ€§æœç´¢
            let similarMemoriesPrompt = "";
            if (paper.snippet && memoryIndex.getCurrentCount() > 0) {
              const queryVector = await embedder(paper.snippet, { pooling: 'mean', normalize: true });
              const searchResult = memoryIndex.searchKnn(Array.from(queryVector.data), 2);
              if (searchResult.neighbors.length > 0) {
                const similarPapersContent = searchResult.neighbors.map(index => memoryContent[index]).filter(Boolean).map((mem, i) => `å†å²ç›¸å…³è®ºæ–‡ ${i+1}:\n- æ ‡é¢˜: ${mem.title}\n- æ‘˜è¦: ${mem.snippet}`).join("\n\n");
                similarMemoriesPrompt = `ä½œä¸ºä¸€ä¸ªæ‹¥æœ‰è®°å¿†çš„ä¸“å®¶ï¼Œè¯·å‚è€ƒä»¥ä¸‹ä¸å½“å‰è®ºæ–‡ä¸»é¢˜ç›¸ä¼¼çš„å†å²è®ºæ–‡ï¼Œè¿›è¡Œå¯¹æ¯”å’Œå…³è”åˆ†æã€‚\n--- å†å²ç›¸ä¼¼è®ºæ–‡ä¸Šä¸‹æ–‡ ---\n${similarPapersContent}\n--------------------------\n`;
              }
            }
            
            // æ­¥éª¤ä¸‰ï¼šæ ¹æ®ç±»å‹é€‰æ‹©åˆ†ææ¡†æ¶
            let summarizationPrompt = '';
            switch (paperType) {
              case "ç»¼è¿°/å›é¡¾å‹":
                console.log("ğŸ“˜ ä½¿ç”¨â€œç»¼è¿°/å›é¡¾å‹â€åˆ†ææ¡†æ¶...");
                summarizationPrompt = `è¯·æ‰®æ¼”ä¸€ä¸ªä¸“ä¸šçš„ç§‘ç ”åŠ©ç†ã€‚${similarMemoriesPrompt}æ ¹æ®æˆ‘æä¾›çš„â€œç»¼è¿°/å›é¡¾å‹â€è®ºæ–‡çš„æ ‡é¢˜å’Œæ‘˜è¦ï¼Œè¯·ä¸¥æ ¼æŒ‰ç…§ä¸‹é¢çš„JSONæ ¼å¼è¿”å›ä½ çš„åˆ†æç»“æœã€‚\n\n### JSONæ ¼å¼è¦æ±‚:\n{"snippet": "...", "interpretation": {"survey_scope": "...", "taxonomy_or_structure": "...", "key_trends_and_insights": "...", "target_audience": "..."}, "paperKeywords": ["..."]}\n\n### å„å­—æ®µç”Ÿæˆè¦æ±‚:\n1. snippet: ç”Ÿæˆä¸€ä¸ªçº¦150å­—çš„â€œå­¦æœ¯æ‘˜è¦â€ï¼Œå®¢è§‚æ¦‚æ‹¬å…¶æ ¸å¿ƒå†…å®¹ã€‚\n2. interpretation: æä¾›â€œæ·±å…¥è§£è¯»â€ï¼Œå¿…é¡»æ˜¯ä¸€ä¸ªåŒ…å«ä»¥ä¸‹å››ä¸ªé”®çš„JSONå¯¹è±¡ï¼š\n   - survey_scope: è¿™ç¯‡ç»¼è¿°è¦†ç›–äº†å“ªä¸ªå…·ä½“ç ”ç©¶é¢†åŸŸï¼Ÿ\n   - taxonomy_or_structure: ä½œè€…æ˜¯å¦‚ä½•å¯¹è¯¥é¢†åŸŸçš„ç°æœ‰å·¥ä½œè¿›è¡Œåˆ†ç±»å’Œç»„ç»‡çš„ï¼Ÿ\n   - key_trends_and_insights: ä½œè€…ä»å›é¡¾ä¸­æ€»ç»“å‡ºäº†å“ªäº›å…³é”®çš„æŠ€æœ¯å‘å±•è¶‹åŠ¿æˆ–æœªæ¥æ´è§ï¼Ÿ\n   - target_audience: è¿™ç¯‡ç»¼è¿°æœ€é€‚åˆå“ªç±»è¯»è€…é˜…è¯»ï¼Ÿ\n3. paperKeywords: æå–æˆ–ç”Ÿæˆ5-7ä¸ªæ ¸å¿ƒå…³é”®è¯ã€‚\n\n### å¾…åˆ†æçš„è®ºæ–‡ä¿¡æ¯ï¼š\næ ‡é¢˜: ${paper.title}\næ‘˜è¦: ${paper.snippet}`;
                break;
              default:
                console.log("ğŸ§ª ä½¿ç”¨â€œå®éªŒ/æ–¹æ³•å‹â€åˆ†ææ¡†æ¶...");
                summarizationPrompt = `è¯·æ‰®æ¼”ä¸€ä¸ªä¸“ä¸šçš„ç§‘ç ”åŠ©ç†ã€‚${similarMemoriesPrompt}æ ¹æ®æˆ‘æä¾›çš„â€œå®éªŒ/æ–¹æ³•å‹â€è®ºæ–‡çš„æ ‡é¢˜å’Œæ‘˜è¦ï¼Œè¯·ä¸¥æ ¼æŒ‰ç…§ä¸‹é¢çš„JSONæ ¼å¼è¿”å›ä½ çš„åˆ†æç»“æœã€‚\n\n### JSONæ ¼å¼è¦æ±‚:\n{"snippet": "...", "interpretation": {"core_contribution": "...", "methodology_summary": "...", "performance_evaluation": "...", "inferred_application": "..."}, "paperKeywords": ["..."]}\n\n### å„å­—æ®µç”Ÿæˆè¦æ±‚:\n1. snippet: ç”Ÿæˆä¸€ä¸ªçº¦150å­—çš„â€œå­¦æœ¯æ‘˜è¦â€ï¼Œå®¢è§‚æ¦‚æ‹¬å…¶æ ¸å¿ƒèƒŒæ™¯ã€æ–¹æ³•å’Œç»“è®ºã€‚\n2. interpretation: æä¾›â€œæ·±å…¥è§£è¯»â€ï¼Œå¿…é¡»æ˜¯ä¸€ä¸ªåŒ…å«ä»¥ä¸‹å››ä¸ªé”®çš„JSONå¯¹è±¡ï¼š\n   - core_contribution: æœ¬æ–‡æœ€å…³é”®çš„æŠ€æœ¯è´¡çŒ®ã€æ–¹æ³•åˆ›æ–°æˆ–è§‚ç‚¹çªç ´æ˜¯ä»€ä¹ˆï¼Ÿ\n   - methodology_summary: å…¶æ ¸å¿ƒæ–¹æ³•çš„æŠ€æœ¯åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ\n   - performance_evaluation: è®ºæ–‡æ˜¯å¦‚ä½•è¯„ä¼°å…¶æ€§èƒ½çš„ï¼Ÿï¼ˆå¦‚ï¼šæ•°æ®é›†ã€åŸºçº¿æ¨¡å‹ã€è¯„ä¼°æŒ‡æ ‡ï¼‰\n   - inferred_application: è¿™é¡¹ç ”ç©¶æœ€ç›´æ¥çš„åº”ç”¨åœºæ™¯æˆ–ç›®æ ‡ç”¨æˆ·æ˜¯è°ï¼Ÿ\n3. paperKeywords: æå–æˆ–ç”Ÿæˆ5-7ä¸ªæ ¸å¿ƒå…³é”®è¯ã€‚\n\n### å¾…åˆ†æçš„è®ºæ–‡ä¿¡æ¯ï¼š\næ ‡é¢˜: ${paper.title}\næ‘˜è¦: ${paper.snippet}`;
                break;
            }

            const summaryData = await queryPerplexityAndParseJson(summarizationPrompt);
            if (!summaryData) { console.log(`ğŸ‘€ è§‚å¯Ÿ: è®ºæ–‡ "${paper.title}" çš„æ‘˜è¦ç”Ÿæˆå¤±è´¥ï¼Œå·²è·³è¿‡ã€‚`); return null; }
            
            console.log(`ğŸ‘€ è§‚å¯Ÿ: å·²æˆåŠŸç”Ÿæˆè®ºæ–‡ "${paper.title}" çš„æ‘˜è¦å’Œè§£è¯»ã€‚`);
            return { id: paper.id, title: paper.title, url: paper.url, authors: paper.authors || [], affiliations: [], journal: paper.journal, publicationDate: paper.publicationDate, ...summaryData };
          }

          // --- ä¸»å‡½æ•° ---
          async function main() {
            try {
              const { pipeline } = await import('@xenova/transformers');
            
              // 1. åŠ è½½æ‰€æœ‰çŠ¶æ€æ–‡ä»¶
              console.log("--- æ­¥éª¤ 1: åŠ è½½çŠ¶æ€æ–‡ä»¶ ---");
              const { content: existingData, sha: dataSha } = await fetchJsonFile(DATA_FILE, { papers: [], keywords: { manual: DEFAULT_KEYWORDS, hot: [] } });
              const { content: keywordHistory, sha: historySha } = await fetchJsonFile(KEYWORD_HISTORY_FILE, []);
              const { sha: fullKeywordsSha } = await fetchJsonFile(FULL_KEYWORDS_FILE, []);
              const { content: processedUrlsData, sha: urlsSha } = await fetchJsonFile(PROCESSED_URLS_FILE, { processed_urls: [] });

              const manualKeywords = existingData.keywords.manual || [];
              const existingUrls = new Set(processedUrlsData.processed_urls);

              // 2. æ„å»ºåˆ†æè®°å¿†åº“ (å°åº“)
              console.log("--- æ­¥éª¤ 2: æ„å»ºåˆ†æè®°å¿†åº“ (å°åº“) ---");
              const memoryIndex = new HierarchicalNSW('l2', VECTOR_DIMENSIONS);
              const maxElements = existingData.papers.length > 0 ? existingData.papers.length : 1;
              memoryIndex.initIndex(maxElements);
              const memoryContent = {};
              const embedder = await pipeline('feature-extraction', EMBEDDING_MODEL);
              if (existingData.papers.length > 0) {
                console.log("ğŸ§  æ­£åœ¨å‘é‡åŒ–åˆ†æè®°å¿†åº“...");
                for (let i = 0; i < existingData.papers.length; i++) {
                    const paper = existingData.papers[i];
                    if (paper.snippet) {
                        const embedding = await embedder(paper.snippet, { pooling: 'mean', normalize: true });
                        memoryIndex.addPoint(Array.from(embedding.data), i);
                        memoryContent[i] = { title: paper.title, snippet: paper.snippet };
                    }
                }
              }
              console.log(`âœ… åˆ†æè®°å¿†åº“æ„å»ºå®Œæˆï¼ŒåŒ…å« ${memoryIndex.getCurrentCount()} æ¡è®°å¿†ã€‚`);

              // 3. æ‹‰å–"å¤§åº“"å¹¶å»é‡
              console.log("--- æ­¥éª¤ 3: ä»arXivæ‹‰å–â€œå¤§åº“â€å¹¶å»é‡ ---");
              const stagingPapers = await fetchStagingPapers(STAGING_AREA_LIMIT);
              const newUniqueStagingPapers = stagingPapers.filter(p => p.url && !existingUrls.has(p.url));
              console.log(`ä»"å¤§åº“"ä¸­å‘ç° ${newUniqueStagingPapers.length} ç¯‡å…¨æ–°è®ºæ–‡ã€‚`);
              
              if (newUniqueStagingPapers.length === 0 && !DEBUG_MODE) {
                  console.log("æ²¡æœ‰å¯å¤„ç†çš„å…¨æ–°è®ºæ–‡ï¼Œå·¥ä½œæµæ­£å¸¸ç»“æŸã€‚"); return;
              }

              // 4. æ™ºèƒ½ç­›é€‰
              console.log("--- æ­¥éª¤ 4: æ™ºèƒ½ç­›é€‰Top Nç¯‡è®ºæ–‡ ---");
              const interestQuery = manualKeywords.join(' ');
              const queryVector = await embedder(interestQuery, { pooling: 'mean', normalize: true });
              const paperSimilarities = [];
              for(const paper of newUniqueStagingPapers) {
                  const paperVector = await embedder(paper.snippet, { pooling: 'mean', normalize: true });
                  const similarity = queryVector.data.reduce((sum, val, i) => sum + val * paperVector.data[i], 0);
                  paperSimilarities.push({ paper, similarity });
              }
              paperSimilarities.sort((a, b) => b.similarity - a.similarity);
              const topPapersToProcess = paperSimilarities.slice(0, TOP_N_TO_PROCESS).map(item => item.paper);
              console.log(`âœ… å·²ç­›é€‰å‡º Top ${topPapersToProcess.length} ç¯‡æœ€ç›¸å…³çš„è®ºæ–‡è¿›è¡Œç²¾å¤„ç†ã€‚`);

              // 5. ç²¾å¤„ç†é€‰å‡ºçš„è®ºæ–‡
              console.log("--- æ­¥éª¤ 5: å¯¹Top Nç¯‡è®ºæ–‡è¿›è¡Œç²¾å¤„ç† ---");
              let processedPapers = [];
              if (DEBUG_MODE) {
                console.log("ğŸš€ è°ƒè¯•æ¨¡å¼å·²å¼€å¯ï¼Œè·³è¿‡æ‰€æœ‰ç²¾å¤„ç†APIè°ƒç”¨ã€‚");
              } else {
                  for (const paper of topPapersToProcess) {
                      const processedPaper = await analyzeSinglePaper(paper, embedder, memoryIndex, memoryContent);
                      if (processedPaper) { processedPapers.push(processedPaper); }
                  }
              }
              
              if (processedPapers.length === 0 && !DEBUG_MODE) { console.log("ç²¾å¤„ç†åæ²¡æœ‰å¯ç”¨çš„æ–°è®ºæ–‡ï¼Œå·¥ä½œæµç»“æŸã€‚"); return; }
              if (processedPapers.length > 0) { console.log(`âœ… æˆåŠŸç²¾å¤„ç†äº† ${processedPapers.length} ç¯‡è®ºæ–‡ã€‚`); }

              // 6. æ›´æ–°å…³é”®è¯å†å²ä¸çƒ­è¯
              console.log("--- æ­¥éª¤ 6: æ›´æ–°å…³é”®è¯ ---");
              const todaysKeywords = processedPapers.flatMap(p => p.paperKeywords || []);
              if (todaysKeywords.length > 0) {
                  const today = new Date().toISOString().split('T')[0];
                  keywordHistory.push({ date: today, keywords: todaysKeywords });
                  while (keywordHistory.length > KEYWORD_HISTORY_WINDOW) { keywordHistory.shift(); }
                  await saveJsonFile(KEYWORD_HISTORY_FILE, keywordHistory, historySha);
              }
              const allKeywordsInWindow = keywordHistory.flatMap(day => day.keywords);
              const keywordFreq = allKeywordsInWindow.reduce((acc, k) => { acc[k] = (acc[k] || 0) + 1; return acc; }, {});
              const sortedKeywords = Object.entries(keywordFreq).sort((a, b) => b[1] - a[1]);
              const newHotKeywords = sortedKeywords.slice(0, 3).map(item => item[0]);
              console.log(`ğŸ”¥ æ–°çš„æ»šåŠ¨çƒ­é—¨å…³é”®è¯ä¸º: ${newHotKeywords.join(', ')}`);
              await saveJsonFile(FULL_KEYWORDS_FILE, sortedKeywords.map(([k, count]) => ({ keyword: k, count })), fullKeywordsSha);
              
              // 7. æ›´æ–°æ°¸ä¹…å»é‡URLåˆ—è¡¨
              console.log("--- æ­¥éª¤ 7: æ›´æ–°æ°¸ä¹…å»é‡URLåˆ—è¡¨ ---");
              const newUrls = processedPapers.map(p => p.url);
              processedUrlsData.processed_urls.push(...newUrls);
              await saveJsonFile(PROCESSED_URLS_FILE, processedUrlsData, urlsSha);

              // 8. æ›´æ–°æ ¸å¿ƒåˆ†æè®°å¿†åº“ (å°åº“)
              console.log("--- æ­¥éª¤ 8: æ›´æ–°æ ¸å¿ƒåˆ†æè®°å¿†åº“ (å°åº“) ---");
              const combinedPapers = [...processedPapers, ...existingData.papers];
              // ---ã€æ–°å¢ä¿®æ”¹ã€‘---: åœ¨è£å‰ªå‰ï¼ŒæŒ‰å‘è¡¨æ—¥æœŸå¯¹æ‰€æœ‰è®ºæ–‡è¿›è¡Œé™åºæ’åˆ—
              // combinedPapers.sort((a, b) => b.publicationDate.localeCompare(a.publicationDate));
              const finalPapers = combinedPapers.slice(0, MAX_PAPERS_TO_KEEP);
              console.log(`å°†ä¿ç•™æœ€æ–°çš„ ${finalPapers.length} ç¯‡è®ºæ–‡åˆ°æ ¸å¿ƒåˆ†æè®°å¿†åº“ã€‚`);
              const newData = { papers: finalPapers, lastUpdate: new Date().toISOString(), keywords: { manual: manualKeywords, hot: newHotKeywords }, lastAutoUpdateDate: new Date().toLocaleDateString('zh-CN', {timeZone: 'Asia/Shanghai'})};
              await saveJsonFile(DATA_FILE, newData, dataSha);
              
              console.log("ğŸš€ æ‰€æœ‰æ•°æ®æ›´æ–°æˆåŠŸï¼Œå·¥ä½œæµç»“æŸã€‚");

            } catch (error) {
              console.error("æ›´æ–°è¿‡ç¨‹ä¸­å‡ºé”™:", error);
              process.exit(1);
            }
          }
          
          main();
          EOL

      - name: Run updater
        id: run_updater_step
        env:
          TRANSFORMERS_CACHE: ./.cache/huggingface/hub # é€šè¿‡ç¯å¢ƒå˜é‡å¼ºåˆ¶æŒ‡å®šæ¨¡å‹ä¸‹è½½è·¯å¾„
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          PERPLEXITY_API_KEY: ${{ secrets.PERPLEXITY_API_KEY }}
        run: node update-data.js

      #å¢åŠ ä¸€ä¸ªè°ƒè¯•æ­¥éª¤ï¼Œç”¨äºæŸ¥çœ‹ç¼“å­˜ç›®å½•çš„çœŸå®ç»“æ„
      # - name: Debug - List Cache Directory Contents
      #   # æ— è®ºä¸Šä¸€æ­¥æ˜¯å¦æˆåŠŸéƒ½è¿è¡Œæ­¤æ­¥éª¤ï¼Œä»¥è·å–æœ€å¤šçš„è°ƒè¯•ä¿¡æ¯
      #   if: always() 
      #   run: |
      #     echo "Listing contents of ./.cache/huggingface/hub directory..."
      #     ls -R ./.cache/huggingface/hub

      - name: Send email notification
        if: success()
        uses: dawidd6/action-send-mail@v5
        with:
          server_address: smtp.163.com
          server_port: 465
          secure: true
          username: 13937372851@163.com
          password: PCf7BnBBtXx9c6wk
          subject: å­¦æœ¯å‘¨æŠ¥å·²æ›´æ–° - ${{ github.repository }}
          body: |
            æ‚¨å¥½ï¼Œ
            æ‚¨çš„å­¦æœ¯å‘¨æŠ¥å·²æˆåŠŸæ›´æ–°ï¼æ–°çš„å­¦æœ¯è®ºæ–‡å·²ç»æ·»åŠ åˆ°æ•°æ®åº“ä¸­ã€‚
            æ‚¨å¯ä»¥é€šè¿‡ä»¥ä¸‹é“¾æ¥è®¿é—®æ‚¨çš„å­¦æœ¯å‘¨æŠ¥ï¼š
            https://shuhanliang.github.io/paper_summary_new/
            æ›´æ–°æ—¶é—´ï¼š${{ github.event.repository.updated_at }}
            ä»“åº“ï¼š${{ github.repository }}
            
            æ­¤é‚®ä»¶ç”±GitHub Actionsè‡ªåŠ¨å‘é€ï¼Œè¯·å‹¿å›å¤ã€‚
          to: blumanchu111@gmail.com, chenhui.a.ye@nokia-sbell.com
          from: å­¦æœ¯å‘¨æŠ¥è‡ªåŠ¨æ›´æ–° <13937372851@163.com>
          nodemailerlog: true
          nodemailerdebug: true
