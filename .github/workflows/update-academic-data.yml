name: Update Academic Data

on:
  schedule:
    # æ¯ä¸ªå·¥ä½œæ—¥ï¼ˆå‘¨ä¸€è‡³å‘¨äº”ï¼‰åŒ—äº¬æ—¶é—´æ—©ä¸Š8:00è¿è¡Œï¼ˆUTCæ—¶é—´0:00ï¼‰
    # æ ¼å¼: åˆ† æ—¶ æ—¥ æœˆ å‘¨å‡  (0-6ï¼Œ0æ˜¯å‘¨æ—¥)
    - cron: '0 0 * * 1-5'
  # å…è®¸æ‰‹åŠ¨è§¦å‘
  workflow_dispatch:

jobs:
  update-data:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install node-fetch@2 dotenv @xenova/transformers hnswlib-node fast-xml-parser

      - name: Create updater script
        run: |
          cat > update-data.js << 'EOL'
          require('dotenv').config();
          const fetch = require('node-fetch');
          // const { pipeline } = require('@xenova/transformers');
          const { HierarchicalNSW } = require('hnswlib-node');


          // --- è°ƒè¯•æ¨¡å¼å¼€å…³ ---
          // è®¾ç½®ä¸º true æ¥è·³è¿‡æ‰€æœ‰APIè°ƒç”¨ï¼Œç›´æ¥ç”¨å·²æœ‰çš„æ•°æ®æµ‹è¯•åç»­æµç¨‹
          // è®¾ç½®ä¸º false ä»¥æ­£å¸¸è°ƒç”¨ Semantic Scholar å’Œ Perplexity API
          const DEBUG_MODE = true;

          // --- é…ç½® ---
          const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
          const GITHUB_REPO = process.env.GITHUB_REPOSITORY;
          const PERPLEXITY_API_KEY = process.env.PERPLEXITY_API_KEY;
          
          const DATA_FILE = 'academic_data.json';
          const KEYWORD_HISTORY_FILE = 'daily_keyword_history.json';
          const FULL_KEYWORDS_FILE = 'keywords_full.json';

          const DEFAULT_KEYWORDS = ["é€šä¿¡", "AI 6G", "Agent", "LLM", "è¯­ä¹‰é€šä¿¡"];
          const KEYWORDS_ENGLISH_MAPPING = {
            "é€šä¿¡": "Communications", "AI 6G": "AI 6G", "Agent": "Agent",
            "LLM": "Large Language Model", "è¯­ä¹‰é€šä¿¡": "Semantic Communications"
          };
          const EMBEDDING_MODEL = 'Xenova/all-MiniLM-L6-v2'; // æ–°å¢ï¼šå®šä¹‰åµŒå…¥æ¨¡å‹
          const VECTOR_DIMENSIONS = 384; // æ–°å¢ï¼šåµŒå…¥æ¨¡å‹çš„ç»´åº¦ï¼Œall-MiniLM-L6-v2æ˜¯384

          // --- æ ¸å¿ƒå·¥å…·å‡½æ•° ---

          // ä»GitHubè·å–é€šç”¨JSONæ–‡ä»¶
          async function fetchJsonFile(fileName, defaultValue = null) {
            try {
              const url = `https://api.github.com/repos/${GITHUB_REPO}/contents/${fileName}`;
              const headers = { 'Authorization': `token ${GITHUB_TOKEN}` };
              const response = await fetch(url, { headers });
              if (!response.ok) {
                if (response.status === 404) {
                  console.log(`æ–‡ä»¶ ${fileName} æœªæ‰¾åˆ°ï¼Œå°†ä½¿ç”¨é»˜è®¤å€¼ã€‚`);
                  return { content: defaultValue, sha: null };
                }
                throw new Error(`GitHub API error for ${fileName}: ${response.status}`);
              }
              const data = await response.json();
              const content = Buffer.from(data.content, 'base64').toString('utf8');
              console.log(`âœ… æˆåŠŸè·å–æ–‡ä»¶ ${fileName}`);
              return { content: JSON.parse(content), sha: data.sha };
            } catch (error) {
              console.error(`è·å–æ–‡ä»¶ ${fileName} æ—¶å‡ºé”™:`, error.message);
              return { content: defaultValue, sha: null };
            }
          }

          // ä¿å­˜é€šç”¨JSONæ–‡ä»¶åˆ°GitHub
          async function saveJsonFile(fileName, data, sha) {
            try {
              const url = `https://api.github.com/repos/${GITHUB_REPO}/contents/${fileName}`;
              const headers = { 'Authorization': `token ${GITHUB_TOKEN}`, 'Content-Type': 'application/json' };
              const content = JSON.stringify(data, null, 2);
              const encodedContent = Buffer.from(content).toString('base64');
              const body = { message: `æ›´æ–°æ•°æ®æ–‡ä»¶: ${fileName}`, content: encodedContent, branch: 'main' };
              if (sha) body.sha = sha;
              const response = await fetch(url, { method: 'PUT', headers, body: JSON.stringify(body) });
              if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`ä¿å­˜åˆ°GitHubæ–‡ä»¶ ${fileName} å¤±è´¥ (${response.status}): ${errorText}`);
              }
              console.log(`âœ… æˆåŠŸä¿å­˜æ–‡ä»¶åˆ° ${fileName}`);
            } catch (error) {
              console.error(`ä¿å­˜æ–‡ä»¶ ${fileName} æ—¶å‡ºé”™:`, error);
              throw error;
            }
          }
          
          // æ–°å¢ï¼šè°ƒç”¨arxiv APIçš„å‡½æ•°
          async function searchArxiv(keywords, limit = 2, maxRetries = 3) {
            const { XMLParser } = await import('fast-xml-parser');

            // 1. æ„å»ºå…³é”®è¯æŸ¥è¯¢éƒ¨åˆ† (arXivè¯­æ³•)
            // å°†ä¸­æ–‡å…³é”®è¯æ˜ å°„ä¸ºè‹±æ–‡
            const englishKeywords = keywords.map(k => KEYWORDS_ENGLISH_MAPPING[k] || k);
            // æ„å»º ti:() OR abs:() æ ¼å¼
            const keywordQuery = englishKeywords.map(k => `(ti:"${k}" OR abs:"${k}")`).join(' OR ');

            // 2. æ„å»ºæ—¥æœŸèŒƒå›´æŸ¥è¯¢éƒ¨åˆ†
            const now = new Date();
            const threeMonthsAgo = new Date();
            threeMonthsAgo.setMonth(now.getMonth() - 3);
            const formatDate = (date) => `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
            const dateFilter = `submittedDate:[${formatDate(threeMonthsAgo)}0000 TO ${formatDate(now)}2359]`;

            // 3. ç»„åˆæœ€ç»ˆæŸ¥è¯¢
            const searchQuery = `(${keywordQuery}) AND ${dateFilter}`;
            console.log(`å‘ arXiv API æŸ¥è¯¢: ${searchQuery}`);

            // 4. æ„å»ºå®Œæ•´URL
            const url = `http://export.arxiv.org/api/query?search_query=${encodeURIComponent(searchQuery)}&max_results=${limit}&sortBy=submittedDate&sortOrder=descending`;

            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url);
                    if (response.status !== 200) throw new Error(`API è¿”å›é”™è¯¯: ${response.status}`);
                    
                    const xmlData = await response.text();
                    const parser = new XMLParser({ ignoreAttributes: false, attributeNamePrefix: "@_" });
                    const jsonData = parser.parse(xmlData);

                    if (!jsonData.feed || !jsonData.feed.entry) {
                        console.log("âœ… arXiv API è¿”å›ç©ºç»“æœæˆ–æ ¼å¼ä¸ç¬¦ã€‚");
                        return [];
                    }

                    // 5. æ˜ å°„æ•°æ®æ ¼å¼
                    const entries = Array.isArray(jsonData.feed.entry) ? jsonData.feed.entry : [jsonData.feed.entry];
                    const papers = entries.map(entry => {
                        // ä½œè€…å¤„ç†
                        let authors = [];
                        if (Array.isArray(entry.author)) {
                            authors = entry.author.map(a => a.name);
                        } else if (entry.author) {
                            authors = [entry.author.name];
                        }
                        
                        // ä»PDFé“¾æ¥ä¸­æå–ID
                        const pdfLink = Array.isArray(entry.link) ? entry.link.find(l => l['@_title'] === 'pdf') : entry.link;
                        const paperId = pdfLink ? pdfLink['@_href'].split('/').pop().replace('v1', '').replace('v2','') : entry.id;

                        return {
                            id: paperId,
                            title: entry.title.replace(/\s+/g, ' ').trim(),
                            url: entry.id,
                            authors: authors,
                            journal: 'arXiv', // ç›´æ¥æ ‡è®°ä¸ºarXiv
                            publicationDate: entry.published.split('T')[0], // YYYY-MM-DD
                            snippet: entry.summary.replace(/\s+/g, ' ').trim(), // ä½œä¸ºåˆå§‹æ‘˜è¦
                            // interpretation å’Œ paperKeywords ç•™ç»™ä¸‹ä¸€æ­¥çš„LLMå¤„ç†
                        };
                    });
                    
                    console.log(`âœ… æˆåŠŸä» arXiv è·å–å¹¶è§£æäº† ${papers.length} ç¯‡è®ºæ–‡ã€‚`);
                    return papers;

                } catch (error) {
                      console.warn(`æŸ¥è¯¢ arXiv æ—¶å‡ºé”™ (ç¬¬ ${i + 1} æ¬¡å°è¯•):`, error.message);
                      if (i === maxRetries - 1) {
                        console.error("å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ”¾å¼ƒè¯·æ±‚ã€‚");
                        return [];
                      }
                      const delay = Math.pow(2, i) * 1000 + (Math.random() * 500);
                      console.log(`å°†åœ¨ ${Math.round(delay / 1000)} ç§’åé‡è¯•...`);
                      await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
                return [];
            }

          // è°ƒç”¨Perplexity APIçš„å‡½æ•°
          async function querySonarPro(question) {
            if (!PERPLEXITY_API_KEY) throw new Error("Perplexity API key is missing");
            const url = "https://api.perplexity.ai/chat/completions";
            const response = await fetch(url, {
              method: 'POST',
              headers: { 'Authorization': `Bearer ${PERPLEXITY_API_KEY}`, 'Content-Type': 'application/json' },
              body: JSON.stringify({ model: "sonar-pro", messages: [{ role: "user", content: question }] })
            });
            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`Perplexity API error (${response.status}): ${errorText}`);
            }
            return await response.json();
          }
          
          // è§£æPerplexityè¿”å›çš„JSON
          async function queryPerplexityAndParseJson(prompt) {
              try {
                  const result = await querySonarPro(prompt);
                  const content = result.choices[0].message.content;
                  const jsonMatch = content.match(/\{[\s\S]*\}/);
                  if (jsonMatch) return JSON.parse(jsonMatch[0]);
                  return null;
              } catch (e) {
                  console.error("è§£æPerplexityè¿”å›çš„JSONæ—¶å‡ºé”™:", e);
                  return null;
              }
          }

          // ---ã€ä¿®æ”¹ç‚¹ 1ã€‘---: é‡æ„ Agent æ ¸å¿ƒé€»è¾‘ï¼Œå®ç°ä¸¤æ­¥å¼è‡ªé€‚åº”åˆ†æ
          async function runAgentAndFetchPapers(keywords, existingPaperUrls, embedder, memoryIndex, memoryContent) {
              console.log("ğŸ¤” æ€è€ƒ: éœ€è¦å¯»æ‰¾æ–°è®ºæ–‡ã€‚");
              console.log("ğŸ¬ è¡ŒåŠ¨: è°ƒç”¨ searchArxiv");
              const papersFromArxiv = await searchArxiv(keywords);
              console.log(`ğŸ‘€ è§‚å¯Ÿ: ä» arXiv è·å¾— ${papersFromArxiv.length} ç¯‡è®ºæ–‡ã€‚`);

              const newUniquePapers = papersFromArxiv.filter(p => p.url && !existingPaperUrls.has(p.url));
              console.log(`ç­›é€‰åå¾—åˆ° ${newUniquePapers.length} ç¯‡å…¨æ–°è®ºæ–‡éœ€è¦å¤„ç†ã€‚`);

              const processedPapers = [];
              for (const paper of newUniquePapers) {
                  console.log(`ğŸ¤” æ€è€ƒ: æ­£åœ¨å¤„ç†è®ºæ–‡ "${paper.title}"`);
                  
                  // ---ã€ä¿®æ”¹ç‚¹ 2ã€‘---: æ­¥éª¤ä¸€ï¼šè®ºæ–‡ç±»å‹åˆ†ç±»
                  console.log("ğŸ” æ­¥éª¤ä¸€: åˆ¤æ–­è®ºæ–‡ç±»å‹...");
                  const classificationPrompt = `
                    æ ¹æ®ä»¥ä¸‹è®ºæ–‡çš„æ ‡é¢˜å’Œæ‘˜è¦ï¼Œè¯·åˆ¤æ–­è¿™ç¯‡è®ºæ–‡æœ€æ¥è¿‘å“ªç§ç±»å‹ï¼Ÿ
                    åªéœ€ä» ["å®éªŒ/æ–¹æ³•å‹", "ç»¼è¿°/å›é¡¾å‹", "è§‚ç‚¹/ç«‹åœºå‹"] ä¸­é€‰æ‹©ä¸€ä¸ªè¿”å›ã€‚
                    è¯·ä¸¥æ ¼æŒ‰ç…§JSONæ ¼å¼è¿”å›ï¼Œä¾‹å¦‚: {"paper_type": "å®éªŒ/æ–¹æ³•å‹"}

                    æ ‡é¢˜: ${paper.title}
                    æ‘˜è¦: ${paper.snippet}
                  `;
                  const classificationResult = await queryPerplexityAndParseJson(classificationPrompt);
                  const paperType = classificationResult ? classificationResult.paper_type : "å®éªŒ/æ–¹æ³•å‹"; // é»˜è®¤ä¸ºå®éªŒå‹
                  console.log(`âœ… è®ºæ–‡ç±»å‹åˆ¤æ–­ä¸º: ${paperType}`);

                  // --- ç›¸ä¼¼æ€§æœç´¢é€»è¾‘ (ä¿æŒä¸å˜) ---
                  let similarMemoriesPrompt = "";
                  if (paper.snippet && memoryIndex.getCurrentCount() > 0) {
                      console.log("ğŸ¬ è¡ŒåŠ¨: å‘é‡åŒ–æ–°è®ºæ–‡æ‘˜è¦å¹¶æœç´¢è®°å¿†åº“...");
                      const queryVector = await embedder(paper.snippet, { pooling: 'mean', normalize: true });
                      const searchResult = memoryIndex.searchKnn(queryVector.data, 2);
                      if (searchResult.neighbors.length > 0) {
                        const similarPapersContent = searchResult.neighbors.map(index => memoryContent[index]).filter(Boolean).map((mem, i) => `å†å²ç›¸å…³è®ºæ–‡ ${i+1}:\n- æ ‡é¢˜: ${mem.title}\n- æ‘˜è¦: ${mem.snippet}`).join("\n\n");
                        similarMemoriesPrompt = `
                          ä½œä¸ºä¸€ä¸ªæ‹¥æœ‰è®°å¿†çš„ä¸“å®¶ï¼Œè¯·å‚è€ƒä»¥ä¸‹ä¸å½“å‰è®ºæ–‡ä¸»é¢˜ç›¸ä¼¼çš„å†å²è®ºæ–‡ï¼Œè¿›è¡Œå¯¹æ¯”å’Œå…³è”åˆ†æã€‚
                          --- å†å²ç›¸ä¼¼è®ºæ–‡ä¸Šä¸‹æ–‡ ---\n${similarPapersContent}\n--------------------------
                          `;
                      }
                  }

                  // ---ã€ä¿®æ”¹ç‚¹ 3ã€‘---: æ­¥éª¤äºŒï¼šæ ¹æ®è®ºæ–‡ç±»å‹ï¼Œé€‰æ‹©ä¸åŒçš„åˆ†ææ¡†æ¶ (Prompt)
                  let summarizationPrompt = '';
                  switch (paperType) {
                    case "ç»¼è¿°/å›é¡¾å‹":
                      console.log("ğŸ“˜ ä½¿ç”¨â€œç»¼è¿°/å›é¡¾å‹â€åˆ†ææ¡†æ¶...");
                      summarizationPrompt = `
                        è¯·æ‰®æ¼”ä¸€ä¸ªä¸“ä¸šçš„ç§‘ç ”åŠ©ç†ã€‚
                        ${similarMemoriesPrompt}
                        æ ¹æ®æˆ‘æä¾›çš„â€œç»¼è¿°/å›é¡¾å‹â€è®ºæ–‡çš„æ ‡é¢˜å’Œæ‘˜è¦ï¼Œè¯·ä¸¥æ ¼æŒ‰ç…§ä¸‹é¢çš„JSONæ ¼å¼è¿”å›ä½ çš„åˆ†æç»“æœã€‚
                        
                        ### JSONæ ¼å¼è¦æ±‚:
                        {"snippet": "...", "interpretation": {"survey_scope": "...", "taxonomy_or_structure": "...", "key_trends_and_insights": "...", "target_audience": "..."}, "paperKeywords": ["..."]}

                        ### å„å­—æ®µç”Ÿæˆè¦æ±‚:
                        1. snippet: ç”Ÿæˆä¸€ä¸ªçº¦150å­—çš„â€œå­¦æœ¯æ‘˜è¦â€ï¼Œå®¢è§‚æ¦‚æ‹¬å…¶æ ¸å¿ƒå†…å®¹ã€‚
                        2. interpretation: æä¾›â€œæ·±å…¥è§£è¯»â€ï¼Œå¿…é¡»æ˜¯ä¸€ä¸ªåŒ…å«ä»¥ä¸‹å››ä¸ªé”®çš„JSONå¯¹è±¡ï¼š
                           - survey_scope: è¿™ç¯‡ç»¼è¿°è¦†ç›–äº†å“ªä¸ªå…·ä½“ç ”ç©¶é¢†åŸŸï¼Ÿ
                           - taxonomy_or_structure: ä½œè€…æ˜¯å¦‚ä½•å¯¹è¯¥é¢†åŸŸçš„ç°æœ‰å·¥ä½œè¿›è¡Œåˆ†ç±»å’Œç»„ç»‡çš„ï¼Ÿ
                           - key_trends_and_insights: ä½œè€…ä»å›é¡¾ä¸­æ€»ç»“å‡ºäº†å“ªäº›å…³é”®çš„æŠ€æœ¯å‘å±•è¶‹åŠ¿æˆ–æœªæ¥æ´è§ï¼Ÿ
                           - target_audience: è¿™ç¯‡ç»¼è¿°æœ€é€‚åˆå“ªç±»è¯»è€…é˜…è¯»ï¼Ÿ
                        3. paperKeywords: æå–æˆ–ç”Ÿæˆ5-7ä¸ªæ ¸å¿ƒå…³é”®è¯ã€‚

                        ### å¾…åˆ†æçš„è®ºæ–‡ä¿¡æ¯ï¼š
                        æ ‡é¢˜: ${paper.title}
                        æ‘˜è¦: ${paper.snippet}
                      `;
                      break;
                    
                    // ---ã€ä¿®æ”¹ç‚¹ 4ã€‘---: é»˜è®¤ä½¿ç”¨æˆ‘ä»¬ä¼˜åŒ–åçš„â€œå®éªŒ/æ–¹æ³•å‹â€åˆ†ææ¡†æ¶
                    case "å®éªŒ/æ–¹æ³•å‹":
                    default:
                      console.log("ğŸ§ª ä½¿ç”¨â€œå®éªŒ/æ–¹æ³•å‹â€åˆ†ææ¡†æ¶...");
                      summarizationPrompt = `
                        è¯·æ‰®æ¼”ä¸€ä¸ªä¸“ä¸šçš„ç§‘ç ”åŠ©ç†ã€‚
                        ${similarMemoriesPrompt}
                        æ ¹æ®æˆ‘æä¾›çš„â€œå®éªŒ/æ–¹æ³•å‹â€è®ºæ–‡çš„æ ‡é¢˜å’Œæ‘˜è¦ï¼Œè¯·ä¸¥æ ¼æŒ‰ç…§ä¸‹é¢çš„JSONæ ¼å¼è¿”å›ä½ çš„åˆ†æç»“æœã€‚

                        ### JSONæ ¼å¼è¦æ±‚:
                        {"snippet": "...", "interpretation": {"core_contribution": "...", "methodology_summary": "...", "performance_evaluation": "...", "inferred_application": "..."}, "paperKeywords": ["..."]}

                        ### å„å­—æ®µç”Ÿæˆè¦æ±‚:
                        1. snippet: ç”Ÿæˆä¸€ä¸ªçº¦150å­—çš„â€œå­¦æœ¯æ‘˜è¦â€ï¼Œå®¢è§‚æ¦‚æ‹¬å…¶æ ¸å¿ƒèƒŒæ™¯ã€æ–¹æ³•å’Œç»“è®ºã€‚
                        2. interpretation: æä¾›â€œæ·±å…¥è§£è¯»â€ï¼Œå¿…é¡»æ˜¯ä¸€ä¸ªåŒ…å«ä»¥ä¸‹å››ä¸ªé”®çš„JSONå¯¹è±¡ï¼š
                           - core_contribution: æœ¬æ–‡æœ€å…³é”®çš„æŠ€æœ¯è´¡çŒ®ã€æ–¹æ³•åˆ›æ–°æˆ–è§‚ç‚¹çªç ´æ˜¯ä»€ä¹ˆï¼Ÿ
                           - methodology_summary: å…¶æ ¸å¿ƒæ–¹æ³•çš„æŠ€æœ¯åŸç†æ˜¯ä»€ä¹ˆï¼Ÿ
                           - performance_evaluation: è®ºæ–‡æ˜¯å¦‚ä½•è¯„ä¼°å…¶æ€§èƒ½çš„ï¼Ÿï¼ˆå¦‚ï¼šæ•°æ®é›†ã€åŸºçº¿æ¨¡å‹ã€è¯„ä¼°æŒ‡æ ‡ï¼‰
                           - inferred_application: è¿™é¡¹ç ”ç©¶æœ€ç›´æ¥çš„åº”ç”¨åœºæ™¯æˆ–ç›®æ ‡ç”¨æˆ·æ˜¯è°ï¼Ÿ
                        3. paperKeywords: æå–æˆ–ç”Ÿæˆ5-7ä¸ªæ ¸å¿ƒå…³é”®è¯ã€‚

                        ### å¾…åˆ†æçš„è®ºæ–‡ä¿¡æ¯ï¼š
                        æ ‡é¢˜: ${paper.title}
                        æ‘˜è¦: ${paper.snippet}
                      `;
                      break;
                  }

                  console.log("ğŸ¬ è¡ŒåŠ¨: è°ƒç”¨ Perplexity API è¿›è¡Œæ·±åº¦åˆ†æ...");
                  const summaryData = await queryPerplexityAndParseJson(summarizationPrompt); 

                  if (summaryData) {
                      console.log(`ğŸ‘€ è§‚å¯Ÿ: å·²æˆåŠŸç”Ÿæˆè®ºæ–‡ "${paper.title}" çš„æ‘˜è¦å’Œè§£è¯»ã€‚`);
                      processedPapers.push({
                          id: paper.id,
                          title: paper.title,
                          url: paper.url,
                          authors: paper.authors || [],
                          affiliations: [],
                          journal: paper.journal,
                          publicationDate: paper.publicationDate,
                          ...summaryData
                      });
                  } else {
                      console.log(`ğŸ‘€ è§‚å¯Ÿ: è®ºæ–‡ "${paper.title}" çš„æ‘˜è¦ç”Ÿæˆå¤±è´¥ï¼Œå·²è·³è¿‡ã€‚`);
                  }
              }
              return processedPapers;
          }


          // --- ä¸»å‡½æ•° ---
          async function main() {
            // --- æ–°å¢ï¼šä½¿ç”¨åŠ¨æ€ import() åŠ è½½ESMæ¨¡å— ---
            const { pipeline } = await import('@xenova/transformers');
            // --- ä¿®æ­£ï¼šä½¿ç”¨æœ€ç»ˆæ­£ç¡®çš„å‘½åå¯¼å‡ºè¯­æ³• ---
            // const { HierarchicalNSW } = await import('hnswlib-node');

            try {
              // --- æ­¥éª¤ 1: åŠ è½½æ‰€æœ‰çŠ¶æ€æ–‡ä»¶ ---
              const { content: existingData, sha: dataSha } = await fetchJsonFile(DATA_FILE, { keywords: { manual: DEFAULT_KEYWORDS, hot: [] }, papers: [] });
              const { content: keywordHistory, sha: historySha } = await fetchJsonFile(KEYWORD_HISTORY_FILE, []);
              const { sha: fullKeywordsSha } = await fetchJsonFile(FULL_KEYWORDS_FILE, []);

              const manualKeywords = existingData.keywords.manual || DEFAULT_KEYWORDS;
              const hotKeywords = existingData.keywords.hot || [];
              const searchKeywords = Array.from(new Set([...manualKeywords, ...hotKeywords]));
              const existingPaperUrls = new Set((existingData.papers || []).map(p => p.url).filter(url => url));

              // ------ æ–°å¢ï¼šåˆå§‹åŒ–åµŒå…¥æ¨¡å‹å’Œå‘é‡è®°å¿†åº“ ---
              console.log("ğŸš€ åˆå§‹åŒ–æ–‡æœ¬åµŒå…¥æ¨¡å‹...");
              const embedder = await pipeline('feature-extraction', EMBEDDING_MODEL);

              console.log("ğŸ§  æ­£åœ¨ä» academic_data.json æ„å»ºå‘é‡è®°å¿†åº“...");
              const memoryIndex = new HierarchicalNSW('l2', VECTOR_DIMENSIONS);

              // å¦‚æœinitIndexéœ€è¦ä¸€ä¸ªéé›¶å‚æ•°ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿å³ä½¿åœ¨æ²¡æœ‰è®ºæ–‡çš„æƒ…å†µä¸‹ä¹Ÿèƒ½å·¥ä½œ
              const maxElements = existingData.papers.length > 0 ? existingData.papers.length : 1;
              memoryIndex.initIndex(maxElements);

              // ã€ä¿®æ”¹ã€‘å£°æ˜ memoryContent ç”¨äºå­˜å‚¨åŸæ–‡
              const memoryContent = {}; // ã€ä¿®æ”¹ã€‘

              if (existingData.papers.length > 0) {
                for (let i = 0; i < existingData.papers.length; i++) {
                    const paper = existingData.papers[i];
                    if (paper.snippet) {
                      const embedding = await embedder(paper.snippet, { pooling: 'mean', normalize: true });
                      memoryIndex.addPoint(embedding.data, i);
                      memoryContent[i] = { title: paper.title, snippet: paper.snippet };
                    }
                }
              }
              console.log(`âœ… å‘é‡è®°å¿†åº“æ„å»ºå®Œæˆï¼ŒåŒ…å« ${memoryIndex.getCurrentCount()} æ¡è®°å¿†ã€‚`);



              // --- æ­¥éª¤ 2: è¿è¡ŒAgentè·å–æ–°è®ºæ–‡ (å«Debugæ¨¡å¼) ---
              let newPapers = [];
              if (DEBUG_MODE) {
                  console.log("ğŸš€ è°ƒè¯•æ¨¡å¼å·²å¼€å¯ï¼Œè·³è¿‡æ‰€æœ‰APIè°ƒç”¨ã€‚");
                  // åœ¨è°ƒè¯•æ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬å‡è£…æ²¡æœ‰è·å–åˆ°æ–°è®ºæ–‡ï¼Œä»¥ä¾¿æµ‹è¯•åç»­çš„å…³é”®è¯ç»Ÿè®¡å’Œæ–‡ä»¶ä¿å­˜é€»è¾‘
              } else {
                  // ä¿®æ”¹ï¼šä¼ å…¥è®°å¿†åº“ç›¸å…³å‚æ•°
                  newPapers = await runAgentAndFetchPapers(searchKeywords, existingPaperUrls, embedder, memoryIndex, memoryContent);
              }

              if (!DEBUG_MODE && newPapers.length === 0) {
                  console.log("æ²¡æœ‰è·å–åˆ°éœ€è¦å¤„ç†çš„æ–°è®ºæ–‡ï¼Œå·¥ä½œæµæ­£å¸¸ç»“æŸã€‚");
                  return;
              }
              if (!DEBUG_MODE) {
                  console.log(`âœ… æˆåŠŸå¤„ç†äº† ${newPapers.length} ç¯‡æ–°è®ºæ–‡ã€‚`);
              }

              // --- æ­¥éª¤ 3: æ›´æ–°10æ—¥æ»šåŠ¨çƒ­è¯ ---
              const todaysKeywords = newPapers.flatMap(p => p.paperKeywords || []);
              if (todaysKeywords.length > 0) {
                  const today = new Date().toISOString().split('T')[0];
                  keywordHistory.push({ date: today, keywords: todaysKeywords });
                  while (keywordHistory.length > 15) {
                      keywordHistory.shift();
                  }
                  await saveJsonFile(KEYWORD_HISTORY_FILE, keywordHistory, historySha);
              }

              const allKeywordsInWindow = keywordHistory.flatMap(day => day.keywords);
              const keywordFreq = allKeywordsInWindow.reduce((acc, k) => { acc[k] = (acc[k] || 0) + 1; return acc; }, {});
              const sortedKeywords = Object.entries(keywordFreq).sort((a, b) => b[1] - a[1]);
              const newHotKeywords = sortedKeywords.slice(0, 3).map(item => item[0]);
              console.log(`ğŸ”¥ æ–°çš„æ»šåŠ¨çƒ­é—¨å…³é”®è¯ä¸º: ${newHotKeywords.join(', ')}`);

              // --- æ­¥éª¤ 4: æ›´æ–°å…¨æ™¯å…³é”®è¯æ–‡ä»¶ ---
              const sortedKeywordsFull = sortedKeywords.map(([k, count]) => ({ keyword: k, count }));
              await saveJsonFile(FULL_KEYWORDS_FILE, sortedKeywordsFull, fullKeywordsSha);
              
              // --- æ­¥éª¤ 5: åˆå¹¶ä¸å½’æ¡£è®ºæ–‡ ---
              const combinedPapers = [...newPapers, ...(existingData.papers || [])];
              const MAX_PAPERS_TO_KEEP = 50;
              const finalPapers = combinedPapers.slice(0, MAX_PAPERS_TO_KEEP);
              console.log(`å°†ä¿ç•™æœ€æ–°çš„ ${finalPapers.length} ç¯‡è®ºæ–‡ã€‚`);

              // --- æ­¥éª¤ 6: å‡†å¤‡å¹¶ä¿å­˜æœ€ç»ˆçš„ä¸»æ•°æ®æ–‡ä»¶ ---
              const newData = {
                papers: finalPapers,
                lastUpdate: new Date().toISOString(),
                keywords: {
                  manual: manualKeywords,
                  hot: newHotKeywords
                },
                lastAutoUpdateDate: new Date().toLocaleDateString('zh-CN', {timeZone: 'Asia/Shanghai'})
              };
              
              await saveJsonFile(DATA_FILE, newData, dataSha);
              console.log("ğŸš€ æ‰€æœ‰æ•°æ®æ›´æ–°æˆåŠŸï¼Œå·¥ä½œæµç»“æŸã€‚");
              
            } catch (error) {
              console.error("æ›´æ–°è¿‡ç¨‹ä¸­å‡ºé”™:", error);
              process.exit(1);
            }
          }
          
          main();
          EOL

      - name: Run updater
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
          PERPLEXITY_API_KEY: ${{ secrets.PERPLEXITY_API_KEY }}
        run: node update-data.js

      - name: Send email notification
        if: success()
        uses: dawidd6/action-send-mail@v5
        with:
          server_address: smtp.163.com
          server_port: 465
          secure: true
          username: 13937372851@163.com
          password: PCf7BnBBtXx9c6wk
          subject: å­¦æœ¯å‘¨æŠ¥å·²æ›´æ–° - ${{ github.repository }}
          body: |
            æ‚¨å¥½ï¼Œ
            
            æ‚¨çš„å­¦æœ¯å‘¨æŠ¥å·²æˆåŠŸæ›´æ–°ï¼æ–°çš„å­¦æœ¯è®ºæ–‡å·²ç»æ·»åŠ åˆ°æ•°æ®åº“ä¸­ã€‚
            
            æ‚¨å¯ä»¥é€šè¿‡ä»¥ä¸‹é“¾æ¥è®¿é—®æ‚¨çš„å­¦æœ¯å‘¨æŠ¥ï¼š
            https://shuhanliang.github.io/paper_summary/
            
            æ›´æ–°æ—¶é—´ï¼š${{ github.event.repository.updated_at }}
            ä»“åº“ï¼š${{ github.repository }}
            
            æ­¤é‚®ä»¶ç”±GitHub Actionsè‡ªåŠ¨å‘é€ï¼Œè¯·å‹¿å›å¤ã€‚
          to: blumanchu111@gmail.com
          from: å­¦æœ¯å‘¨æŠ¥è‡ªåŠ¨æ›´æ–° <13937372851@163.com>
          nodemailerlog: true
          nodemailerdebug: true
