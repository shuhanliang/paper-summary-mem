<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>学术周报生成器 - 海报版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e9eef2; 
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }
        ::-webkit-scrollbar {
            width: 0px; /* Hide vertical scrollbar */
            height: 0px; /* Hide horizontal scrollbar */
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: transparent;
        }
        .keyword-tag {
            transition: all 0.2s ease-in-out;
        }
        .keyword-tag:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        #report-content-wrapper {
            perspective: 1500px;
            width: 100%;
            height: calc(100vh - 300px);
            min-height: 600px;
            margin: 0 auto;
        }
        #report-content {
            display: flex; 
            overflow-x: auto; /* Allow scrolling but hide the scrollbar */
            overflow-y: hidden; 
            scroll-snap-type: x mandatory; 
            -webkit-overflow-scrolling: touch; 
            padding: 20px 0;
            height: 100%;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        .report-card-poster {
            scroll-snap-align: center; 
            flex: 0 0 calc(min(90%, 595px)); /* A4 width in pixels */
            height: calc(100% - 40px); /* Subtract padding */
            margin: 0 15px; 
            border-radius: 16px; 
            background-color: #ffffff;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1), 0 5px 10px rgba(0,0,0,0.04);
            transition: transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.6s ease-out;
            transform-style: preserve-3d;
            opacity: 0.7;
            transform: scale(0.9) rotateY(25deg) translateX(10px); 
            overflow: hidden;
            aspect-ratio: 1/1.414; /* A4 ratio */
        }
        .report-card-poster.is-active {
            opacity: 1;
            transform: scale(1) rotateY(0deg) translateX(0px); 
            box-shadow: 0 15px 35px rgba(0,0,0,0.15), 0 8px 15px rgba(0,0,0,0.08);
        }
        .poster-grid {
            display: grid;
            grid-template-columns: 38% 62%; 
            height: 100%;
            max-height: 100%;
        }
        .poster-left-column {
            background-color: #f0f4f8; 
            padding: min(24px, 3vh);
            display: flex;
            flex-direction: column;
            justify-content: space-between; 
            border-right: 1px solid #dde4eb;
            overflow-y: auto; 
        }
        .poster-right-column {
            padding: min(24px, 3vh);
            display: flex;
            flex-direction: column;
            overflow-y: auto; 
        }
        .poster-title {
            font-size: clamp(1rem, 2vw, 1.25rem);
            font-weight: 700;
            color: #1e3a8a; 
            line-height: 1.3;
            margin-bottom: 12px;
        }
        .poster-authors {
            font-size: clamp(0.75rem, 1.5vw, 0.85rem);
            color: #374151;
            margin-bottom: 8px;
        }
        .poster-authors sup {
            color: #059669; 
        }
        .poster-affiliations {
            font-size: clamp(0.7rem, 1.2vw, 0.75rem);
            color: #6b7280;
            margin-bottom: 16px;
        }
        .poster-affiliations span {
            display: block;
            margin-bottom: 2px;
        }
        .poster-journal-info {
            font-size: clamp(0.75rem, 1.5vw, 0.8rem);
            color: #4b5563;
        }
        .poster-journal-info strong {
            color: #1e3a8a;
        }
        .poster-section-title {
            font-size: clamp(0.8rem, 1.8vw, 0.9rem);
            font-weight: 600;
            color: #1e3a8a;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 2px solid #60a5fa; 
            padding-bottom: 4px;
            display: inline-block;
        }
        .poster-abstract, .poster-interpretation-content { 
            font-size: clamp(0.75rem, 1.5vw, 0.85rem);
            color: #334155;
            line-height: 1.6;
            text-align: justify;
            margin-bottom: 16px;
        }
        .poster-interpretation { 
             background-color: #f8fafc; 
             padding: 10px;
             border-radius: 6px;
             border: 1px solid #e2e8f0;
        }
        .poster-keywords-container .poster-keywords-tag { 
            background-color: #dbeafe; 
            color: #1e40af; 
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 500;
            margin-right: 6px;
            margin-bottom: 6px;
            display: inline-block;
        }
        .poster-read-more-btn {
            display: block;
            width: 100%;
            text-align: center;
            background-color: #2563eb; 
            color: white;
            font-weight: 600;
            padding: 10px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(37, 99, 235, 0.2);
            transition: all 0.2s ease-in-out;
            margin-top: auto; 
        }
        .poster-read-more-btn:hover {
            background-color: #1d4ed8;
            box-shadow: 0 6px 10px rgba(37, 99, 235, 0.3);
            transform: translateY(-1px);
        }
        #loading-message-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(1rem, 2vw, 1.1rem);
            color: #4b5563;
        }
        
        /* Pagination dots */
        .pagination-dots {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: -25px; /* Moved up further from previous -10px */
            gap: 8px;
            position: relative;
            z-index: 10;
        }
        .pagination-count {
            font-size: 0.9rem;
            color: #64748b;
            margin-bottom: 5px;
        }
        .dots-container {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .pagination-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #cbd5e1;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .pagination-dot.active {
            background-color: #2563eb;
            transform: scale(1.2);
        }
        
        /* Responsive container adjustments */
        .container {
            width: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 min(24px, 4vw);
        }
        
        /* Responsive grid layout */
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr !important;
            }
            #report-content-wrapper {
                height: calc(100vh - 200px);
            }
            .report-card-poster {
                flex: 0 0 calc(min(95%, 595px));
                margin: 0 10px;
            }
            .poster-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            .poster-left-column {
                border-right: none;
                border-bottom: 1px solid #dde4eb;
                padding: min(16px, 2vh);
            }
            .poster-right-column {
                padding: min(16px, 2vh);
            }
        }
        
        /* Keyword management section responsive adjustments */
        #keyword-management {
            position: relative;
            height: fit-content;
            max-height: calc(100vh - 400px);
            overflow-y: auto;
        }
        
        /* Update info section responsive adjustments */
        #update-info {
            height: fit-content;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 min-h-screen flex flex-col items-center py-8 px-4">

    <div class="container mx-auto max-w-5xl w-full">
        <header class="mb-10 text-center">
            <h1 class="text-4xl font-bold text-sky-700">学术周报</h1>
            <p class="text-slate-600 mt-2">每日清晨，为您定制专属学术动态</p>
        </header>

        <!-- 开发者工具栏（默认隐藏） -->
        <div id="dev-toolbar" class="hidden bg-gray-900 text-white p-4 rounded-lg mb-6 relative">
            <button id="close-dev-toolbar" class="absolute top-2 right-2 text-white hover:text-gray-300">✕</button>
            <h3 class="text-lg font-bold mb-2">开发者工具</h3>
            <div class="grid gap-3">
                <div>
                    <label class="block mb-1 text-sm">API密钥（仅用于本地测试）:</label>
                    <input type="password" id="dev-api-key" class="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded text-white" placeholder="输入Perplexity API密钥进行本地测试">
                </div>
                <div class="flex items-center">
                    <label class="inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="dev-debug-mode" class="sr-only peer">
                        <div class="relative w-11 h-6 bg-gray-700 rounded-full peer peer-checked:bg-blue-500 peer-focus:ring-2 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:after:translate-x-full"></div>
                        <span class="ml-3 text-sm">启用调试模式</span>
                    </label>
                    <button id="apply-dev-settings" class="ml-auto bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-sm">应用</button>
                </div>
                <p class="text-xs text-gray-400 mt-1">警告: API密钥仅存储在本地，用于开发测试。请勿在生产环境或共享设备上使用此功能。</p>
            </div>
        </div>

        <main class="grid md:grid-cols-3 gap-8">
            <aside class="md:col-span-1 space-y-8">
                <section id="keyword-management" class="bg-white p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 text-sky-600 border-b pb-2">关键词管理</h2>
                    <form id="add-keyword-form" class="space-y-4">
                        <div>
                            <label for="keyword-input" class="block text-sm font-medium text-slate-700 mb-1">添加关键词:</label>
                            <input type="text" id="keyword-input" placeholder="例如：人工智能, 机器学习" class="w-full px-4 py-2 border border-slate-300 rounded-lg focus:ring-sky-500 focus:border-sky-500 transition duration-150 ease-in-out">
                        </div>
                        <button type="submit" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:shadow-lg transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-opacity-50">
                            添加关键词
                        </button>
                    </form>
                    <div id="keywords-list-container" class="mt-6">
                        <h3 class="text-lg font-semibold text-slate-700 mb-3">我的关键词:</h3>
                        <div id="keywords-list" class="flex flex-wrap gap-2"></div>
                        <p id="no-keywords-message" class="text-sm text-slate-500 mt-2" style="display: none;">暂无关键词，请添加。</p>
                    </div>
                </section>

                <section id="update-info" class="bg-white p-6 rounded-xl shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 text-sky-600 border-b pb-2">更新信息</h2>
                    <div class="space-y-3 text-sm text-slate-600">
                        <p><span class="font-semibold">自动更新:</span> 系统将于每个工作日（周一至周五）北京时间 <strong class="text-sky-700">早上 8:00</strong> 尝试自动获取新内容。</p>
                        <p id="last-updated"><span class="font-semibold">上次内容获取时间:</span> <span id="last-updated-time" class="text-sky-700">正在加载...</span></p>
                        <p id="next-scheduled-update"><span class="font-semibold">下次计划自动获取:</span> <span id="next-update-time" class="text-sky-700">正在计算...</span></p>
                        <button id="manual-refresh-button" class="mt-4 w-full bg-teal-500 hover:bg-teal-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:shadow-lg transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-opacity-50">
                            手动刷新
                        </button>
                        <p class="text-xs text-slate-500 mt-2 text-center">点击刷新将调用API获取最新论文</p>
                    </div>
                </section>
            </aside>

            <section id="report-display-container" class="md:col-span-2 bg-transparent p-0 rounded-xl">
                <div class="flex justify-between items-center mb-4 px-1">
                    <h2 class="text-2xl font-semibold text-sky-700">本周学术精选</h2>
                    <span id="report-date" class="text-sm text-slate-500"></span>
                </div>
                <div id="report-content-wrapper">
                    <div id="report-content" class="h-[600px]">
                        <div id="loading-message-container">
                            <p id="loading-message">正在加载学术周报...</p>
                        </div>
                    </div>
                    <div class="pagination-dots" id="pagination-container">
                        <!-- Pagination count above dots -->
                        <span class="pagination-count" id="pagination-count">0/0</span>
                        <div class="dots-container" id="dots-container">
                            <!-- Pagination dots will be generated here -->
                        </div>
                    </div>
                </div>
            </section>
        </main>

        <footer class="mt-12 text-center text-sm text-slate-500">
            <p>&copy; <span id="current-year"></span> 学术周报生成器. 保留所有权利.</p>
        </footer>
    </div>

    <script>
        // --- DOM Elements ---
        const keywordInput = document.getElementById('keyword-input');
        const addKeywordForm = document.getElementById('add-keyword-form');
        const keywordsListDiv = document.getElementById('keywords-list');
        const noKeywordsMessage = document.getElementById('no-keywords-message');
        
        const reportContentDiv = document.getElementById('report-content');
        const loadingMessageContainer = document.getElementById('loading-message-container');
        const loadingMessage = document.getElementById('loading-message');
        const reportDateSpan = document.getElementById('report-date');
        const paginationContainer = document.getElementById('pagination-container');
        const paginationCount = document.getElementById('pagination-count');
        
        const lastUpdatedTimeSpan = document.getElementById('last-updated-time');
        const nextUpdateTimeSpan = document.getElementById('next-update-time');
        const manualRefreshButton = document.getElementById('manual-refresh-button');
        const currentYearSpan = document.getElementById('current-year');

        // 开发者工具栏元素
        const devToolbar = document.getElementById('dev-toolbar');
        const closeDevToolbarBtn = document.getElementById('close-dev-toolbar');
        const devApiKeyInput = document.getElementById('dev-api-key');
        const devDebugModeToggle = document.getElementById('dev-debug-mode');
        const applyDevSettingsBtn = document.getElementById('apply-dev-settings');

        // --- State ---
        let userKeywords = ["通信", "AI 6G", "Agent", "LLM", "语义通信"]; 
        // English mapping for better API results
        let userKeywordsEnglish = {
            "通信": "Communications",
            "AI 6G": "AI 6G",
            "Agent": "Agent",
            "LLM": "Large Language Model",
            "语义通信": "Semantic Communications"
        };
        let activeKeywords = []; 
        let intersectionObserver;
        let autoUpdateInterval;
        let keywordsModified = false;
        let isDebugMode = false; // 调试模式标志

        // 安全地处理API密钥 - 生产环境中不应该直接暴露
        const PERPLEXITY_API_KEY = ""; // 生产环境中使用空字符串
        const LOCAL_STORAGE_PAPERS_KEY = 'academicReportPapersData';
        const LOCAL_STORAGE_LAST_FETCH_KEY = 'academicReportLastFetchTime';
        const LOCAL_STORAGE_LAST_AUTO_UPDATE_DATE_KEY = 'academicReportLastAutoUpdateDate';

        // GitHub API configuration
        const GITHUB_USERNAME = "Jannhsu"; // 已更新为您的GitHub用户名
        const GITHUB_REPO = "paper_summary"; // 已更新为您的仓库名
        const GITHUB_TOKEN = ""; // 为安全起见，建议后续手动添加
        const GITHUB_API_BASE = `https://api.github.com/repos/${GITHUB_USERNAME}/${GITHUB_REPO}/contents`;
        const GITHUB_DATA_FILE = "academic_data.json"; // 存储数据的文件名
        const USE_GITHUB_STORAGE = true; // 已启用GitHub存储


        // --- Utility Functions ---
        function getBeijingTime() {
            const now = new Date();
            const utcOffset = now.getTimezoneOffset() * 60000;
            const utcTime = now.getTime() + utcOffset;
            const beijingTime = new Date(utcTime + (3600000 * 8)); 
            return beijingTime;
        }

        function getFormattedDateTime(dateObject) {
            return dateObject.toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' });
        }
        
        // --- GitHub Data Persistence Functions ---
        async function fetchFromGitHub() {
            if (!USE_GITHUB_STORAGE) return null;
            
            try {
                console.log("Fetching data from GitHub...");
                const url = `${GITHUB_API_BASE}/${GITHUB_DATA_FILE}`;
                const headers = GITHUB_TOKEN ? { 'Authorization': `token ${GITHUB_TOKEN}` } : {};
                
                const response = await fetch(url, { headers });
                
                if (!response.ok) {
                    if (response.status === 404) {
                        console.log("Data file not found on GitHub. Will create it after data is available.");
                        return null;
                    }
                    throw new Error(`GitHub API error: ${response.status}`);
                }
                
                const data = await response.json();
                // Fix: Use proper UTF-8 decoding for base64 content
                // Convert base64 to binary string and then decode as UTF-8
                const binaryString = atob(data.content);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const content = new TextDecoder('utf-8').decode(bytes);
                
                const parsedData = JSON.parse(content);
                console.log("Successfully fetched data from GitHub");
                return parsedData;
            } catch (error) {
                console.error("Error fetching from GitHub:", error);
                return null;
            }
        }

        async function saveToGitHub(dataToSave) {
            if (!USE_GITHUB_STORAGE) return false;
            
            try {
                console.log("Saving data to GitHub...");
                const content = JSON.stringify(dataToSave, null, 2);
                
                // Fix: Properly encode UTF-8 content to base64
                // First convert string to UTF-8 bytes, then encode as base64
                const encoder = new TextEncoder();
                const bytes = encoder.encode(content);
                let binaryString = '';
                bytes.forEach(byte => binaryString += String.fromCharCode(byte));
                const encodedContent = btoa(binaryString);
                
                // First, check if file exists and get its SHA if it does
                let sha = "";
                const checkUrl = `${GITHUB_API_BASE}/${GITHUB_DATA_FILE}`;
                const headers = {
                    'Authorization': `token ${GITHUB_TOKEN}`,
                    'Content-Type': 'application/json'
                };
                
                try {
                    const checkResponse = await fetch(checkUrl, { headers });
                    if (checkResponse.ok) {
                        const fileData = await checkResponse.json();
                        sha = fileData.sha;
                    }
                } catch (error) {
                    console.log("File doesn't exist yet, will create new file");
                }
                
                // Prepare request body
                const body = {
                    message: `Update academic data - ${new Date().toISOString()}`,
                    content: encodedContent,
                    branch: "main" // or "master" depending on your repository
                };
                
                if (sha) body.sha = sha; // Include SHA if file exists
                
                // Create or update file
                const saveResponse = await fetch(checkUrl, {
                    method: 'PUT',
                    headers,
                    body: JSON.stringify(body)
                });
                
                if (!saveResponse.ok) {
                    throw new Error(`Failed to save to GitHub: ${saveResponse.status}`);
                }
                
                console.log("Successfully saved data to GitHub");
                return true;
            } catch (error) {
                console.error("Error saving to GitHub:", error);
                return false;
            }
        }

        // Combined data structure for GitHub storage
        async function saveSharedData(papers) {
            if (!USE_GITHUB_STORAGE) return false;
            
            const sharedData = {
                papers,
                lastUpdate: getBeijingTime().toISOString(),
                keywords: activeKeywords,
                lastAutoUpdateDate: localStorage.getItem(LOCAL_STORAGE_LAST_AUTO_UPDATE_DATE_KEY)
            };
            
            return await saveToGitHub(sharedData);
        }

        async function loadSharedData() {
            if (!USE_GITHUB_STORAGE) return null;
            
            const data = await fetchFromGitHub();
            if (data) {
                if (data.papers) renderReport(data.papers);
                if (data.keywords) {
                    activeKeywords = data.keywords;
                    renderActiveKeywords();
                }
                if (data.lastUpdate) {
                    localStorage.setItem(LOCAL_STORAGE_LAST_FETCH_KEY, data.lastUpdate);
                }
                if (data.lastAutoUpdateDate) {
                    localStorage.setItem(LOCAL_STORAGE_LAST_AUTO_UPDATE_DATE_KEY, data.lastAutoUpdateDate);
                }
                keywordsModified = false;
                updateTimestamps(false);
                return data;
            }
            return null;
        }
        
        // --- Keyword Management ---
        function renderActiveKeywords() {
            keywordsListDiv.innerHTML = '';
            noKeywordsMessage.style.display = activeKeywords.length === 0 ? 'block' : 'none';
            activeKeywords.forEach((keyword, index) => {
                const keywordTag = document.createElement('span');
                keywordTag.className = 'keyword-tag bg-sky-100 text-sky-700 text-sm font-medium px-3 py-1.5 rounded-full flex items-center shadow-sm cursor-default transition-all';
                keywordTag.textContent = keyword;
                const deleteButton = document.createElement('button');
                deleteButton.className = 'ml-2 text-sky-500 hover:text-sky-700 font-bold text-xs';
                deleteButton.textContent = '✕';
                deleteButton.title = `删除关键词 "${keyword}"`;
                deleteButton.onclick = () => deleteActiveKeyword(index);
                keywordTag.appendChild(deleteButton);
                keywordsListDiv.appendChild(keywordTag);
            });
        }

        async function addActiveKeyword(keyword) {
            const trimmedKeyword = keyword.trim();
            if (trimmedKeyword && !activeKeywords.includes(trimmedKeyword)) {
                activeKeywords.push(trimmedKeyword);
                saveActiveKeywordsToLocalStorage();
                renderActiveKeywords();
                console.log("Keywords changed, fetching new papers.");
                keywordsModified = true;
                await loadOrFetchPapers(true);
            }
            keywordInput.value = '';
        }

        async function deleteActiveKeyword(index) {
            activeKeywords.splice(index, 1);
            saveActiveKeywordsToLocalStorage();
            renderActiveKeywords();
            console.log("Keywords changed, fetching new papers.");
            keywordsModified = true;
            await loadOrFetchPapers(true);
        }

        function loadActiveKeywordsFromLocalStorage() {
            const storedKeywords = localStorage.getItem('academicReportKeywords');
            if (storedKeywords) {
                activeKeywords = JSON.parse(storedKeywords);
                 if (activeKeywords.length === 0 && userKeywords.length > 0) { 
                    activeKeywords = [...userKeywords];
                }
            } else if (userKeywords.length > 0) { 
                 activeKeywords = [...userKeywords];
            }
        }

        function saveActiveKeywordsToLocalStorage() {
            localStorage.setItem('academicReportKeywords', JSON.stringify(activeKeywords));
            
            // Also save to GitHub if enabled
            if (USE_GITHUB_STORAGE) {
                const papersData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PAPERS_KEY) || '[]');
                saveSharedData(papersData);
            }
        }

        // --- Perplexity AI API Interaction ---
        async function querySonarPro(apiKey, question) {
            const url = "https://api.perplexity.ai/chat/completions";
            
            if (apiKey === "YOUR_PERPLEXITY_API_KEY_HERE" || !apiKey) { 
                console.warn("Perplexity API key is a placeholder or missing. Real API call will not be made.");
                return Promise.reject(new Error("API key is a placeholder. Please replace it with your actual key for API calls."));
            }

            console.log(`Attempting to call Perplexity API with model 'sonar-pro' for question: "${question.substring(0,100)}..."`);
            let response;
            try {
                response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        model: "sonar-pro", 
                        messages: [{ role: "user", content: question }]
                    })
                });
            } catch (networkError) {
                console.error("Network error during Perplexity API call:", networkError);
                throw new Error(`Network error: ${networkError.message}`);
            }

            if (!response.ok) {
                const errorBody = await response.text(); 
                console.error("Perplexity API Error Response Status:", response.status);
                console.error("Perplexity API Error Response Body:", errorBody);
                throw new Error(`Perplexity API request failed with status ${response.status}: ${errorBody}`);
            }
            
            const result = await response.json();
            console.log("Perplexity API Raw JSON Result:", JSON.stringify(result, null, 2)); 
            
            if (!result.choices || !result.choices[0] || !result.choices[0].message || typeof result.choices[0].message.content === 'undefined') {
                console.error("Unexpected API response structure from Perplexity:", result);
                throw new Error("Unexpected response structure from Perplexity API. 'content' field is missing or invalid.");
            }

            const content = result.choices[0].message.content;
            const citations = result.citations || []; 
            console.log("Extracted content from API:", content.substring(0, 500) + "...");
            console.log("Extracted citations from API:", citations);
            
            return { content, citations };
        }

        function parsePaperInfoFromContent(content, citations, englishKeyword, originalKeyword = null) {
            console.log(`Attempting to parse content for keyword "${englishKeyword}":\n---BEGIN CONTENT---\n${content}\n---END CONTENT---`);
            
            // If no original keyword provided, use the English one
            const keywordForDisplay = originalKeyword || englishKeyword;
            
            let paper = {
                id: `paper-api-${Date.now()}-${Math.random().toString(36).substring(7)}`,
                title: "标题提取失败",
                url: "#",
                authors: ["作者提取失败"],
                affiliations: ["单位提取失败"],
                journal: "期刊/会议提取失败",
                publicationDate: `${getBeijingTime().getFullYear()}年`,
                paperKeywords: [keywordForDisplay, "解析数据"],
                snippet: "摘要未能提取。",
                interpretation: "深入解读未能提取。"
            };

            try {
                if (citations && citations.length > 0) {
                    const potentialUrl = citations.find(c => c.url && (c.url.includes('arxiv.org') || c.url.includes('doi.org') || c.url.includes('acm.org') || c.url.includes('ieee.org')))?.url;
                    if (potentialUrl) paper.url = potentialUrl;
                    else if (citations[0].url) paper.url = citations[0].url;
                }

                const extractField = (text, labelStart, nextLabelStarts = []) => {
                    const labelEndChars = ":："; 
                    let bestMatch = null;
                
                    for (const start of labelStart) {
                        for (const endChar of labelEndChars) {
                            const fullLabel = start + endChar;
                            let startIndex = text.toLowerCase().indexOf(fullLabel.toLowerCase());
                            if (startIndex === -1) continue;
                
                            startIndex += fullLabel.length; 
                
                            let endIndex = text.length;
                            if (nextLabelStarts.length > 0) {
                                for (const nextStart of nextLabelStarts) {
                                    for (const nextEndChar of labelEndChars) {
                                        const nextFullLabel = nextStart + nextEndChar;
                                        const tempEndIndex = text.toLowerCase().indexOf(nextFullLabel.toLowerCase(), startIndex);
                                        if (tempEndIndex !== -1 && tempEndIndex < endIndex) {
                                            endIndex = tempEndIndex;
                                        }
                                    }
                                }
                            }
                            
                            const doubleNewlineIndex = text.indexOf("\n\n", startIndex);
                            if (doubleNewlineIndex !== -1 && doubleNewlineIndex < endIndex) {
                                let isPartOfNextLabel = false;
                                if(nextLabelStarts.length > 0){
                                    for (const nextStart of nextLabelStarts) {
                                        for (const nextEndChar of labelEndChars) {
                                            const nextFullLabel = nextStart + nextEndChar;
                                            if (text.substring(doubleNewlineIndex, endIndex).toLowerCase().includes(nextFullLabel.toLowerCase())) {
                                                isPartOfNextLabel = true;
                                                break;
                                            }
                                        }
                                        if(isPartOfNextLabel) break;
                                    }
                                }
                                if(!isPartOfNextLabel) endIndex = doubleNewlineIndex;
                            }

                            const extracted = text.substring(startIndex, endIndex).trim();
                            if (extracted) {
                                if (!bestMatch || extracted.length > bestMatch.length) {
                                    bestMatch = extracted;
                                }
                            }
                        }
                    }
                    return bestMatch;
                };
                
                const allPossibleNextLabels = ["authors", "作者", "affiliations", "单位", "journal/conference", "期刊/会议", "publication year", "发表年份", "url", "abstract", "摘要", "in-depth analysis", "深入解读与分析", "深入解读", "keywords", "关键词"];

                paper.title = extractField(content, ["title", "标题"], allPossibleNextLabels.filter(l => !["title", "标题"].includes(l.toLowerCase()))) || paper.title;
                
                const authorsText = extractField(content, ["authors", "作者"], allPossibleNextLabels.filter(l => !["authors", "作者"].includes(l.toLowerCase())));
                if (authorsText) paper.authors = authorsText.split(/,|、|and/i).map(a => a.trim()).filter(a => a.length > 0);

                const affiliationsText = extractField(content, ["affiliations", "单位"], allPossibleNextLabels.filter(l => !["affiliations", "单位"].includes(l.toLowerCase())));
                if (affiliationsText) paper.affiliations = affiliationsText.split(/;/).map(a => a.trim()).filter(a => a.length > 0);
                
                paper.journal = extractField(content, ["journal/conference", "期刊/会议"], allPossibleNextLabels.filter(l => !["journal/conference", "期刊/会议"].includes(l.toLowerCase()))) || paper.journal;
                paper.publicationDate = extractField(content, ["publication year", "发表年份"], allPossibleNextLabels.filter(l => !["publication year", "发表年份"].includes(l.toLowerCase()))) || paper.publicationDate;
                
                const urlText = extractField(content, ["url"], allPossibleNextLabels.filter(l => !["url"].includes(l.toLowerCase())));
                if (urlText && urlText.startsWith("http")) paper.url = urlText;

                paper.snippet = extractField(content, ["abstract", "摘要"], allPossibleNextLabels.filter(l => !["abstract", "摘要"].includes(l.toLowerCase()))) || paper.snippet;
                paper.interpretation = extractField(content, ["in-depth analysis", "深入解读与分析", "深入解读"], allPossibleNextLabels.filter(l => !["in-depth analysis", "深入解读与分析", "深入解读"].includes(l.toLowerCase()))) || paper.interpretation;

                const keywordsText = extractField(content, ["keywords", "关键词"]); 
                if (keywordsText) {
                    paper.paperKeywords = [keywordForDisplay, ...keywordsText.split(/,|、/).map(k => k.trim()).filter(k => k.length > 0)];
                }
                
                console.log("Parsed paper info:", JSON.stringify(paper, null, 2));
                return paper;

            } catch (e) {
                console.error(`Error during parsing content for keyword "${englishKeyword}":`, e);
                console.error("Content that caused parsing error:\n", content);
                return paper; 
            }
        }


        async function fetchPapersFromAPI(keywordsToSearch) {
            // 优先使用开发者工具设置的临时API密钥
            const effectiveApiKey = window.tempApiKey || PERPLEXITY_API_KEY;
            
            if (!effectiveApiKey || effectiveApiKey === "YOUR_PERPLEXITY_API_KEY_HERE") {
                console.warn("API Key is missing or placeholder. Using fallback mock data generation.");
                return generateFallbackMockPapers(keywordsToSearch);
            }

            if (keywordsToSearch.length === 0) {
                console.warn("No keywords provided for search.");
                return [];
            }

            console.log(`Fetching papers from Perplexity API for keywords: ${keywordsToSearch.join(', ')}`);
            loadingMessage.textContent = `正在通过API根据关键词 [${keywordsToSearch.join(', ')}] 检索最新文献...`;
            loadingMessageContainer.style.display = 'flex';
            reportContentDiv.innerHTML = ''; 
            reportContentDiv.appendChild(loadingMessageContainer);

            const fetchedPapers = [];
            const maxPapersToFetch = 5;

            // Combine all keywords for a single search
            const combinedKeywords = keywordsToSearch.join(', ');
            
            // Get English translations of keywords for better API results
            const englishKeywords = keywordsToSearch.map(keyword => userKeywordsEnglish[keyword] || keyword);
            const combinedEnglishKeywords = englishKeywords.join(', ');
            
            console.log(`Using English keywords for API query: ${combinedEnglishKeywords}`);
            
            // Create a more specific prompt asking for papers related to multiple keywords
            const question = `
            Please find ${maxPapersToFetch} highly relevant academic research papers that MUST be originally published in English (not translated from another language). The papers should be EXTREMELY RECENT (published within the last 1-3 months is strongly preferred) or very recent papers that are currently trending/highly-cited in the academic community. 
            
            Find papers specifically related to the following combination of keywords as a whole: "${combinedEnglishKeywords}".
            
            These papers should ideally discuss topics at the intersection of MULTIPLE keywords in the list, not just focus on one keyword. Search primarily on platforms like arXiv, ACL, IEEE, ACM, Nature, Science, and major journals or conferences where cutting-edge research is published first. 
            
            For each paper, provide the information using the following EXACT format:
            
            PAPER 1:
            Title: [The exact English title of the paper]
            Authors: [List of authors, separated by commas. Example: John Doe, Jane Smith]
            Affiliations: [List of main affiliations, separated by semicolons. Example: University A; Organization B]
            Journal/Conference: [Name of the journal or conference]
            Publication Year: [Year and month if available, e.g., 2024-May]
            URL: [A direct, accessible URL to the paper (e.g., ArXiv, DOI, official publisher page)]
            Abstract: [请用中文提供详细的论文摘要，大约150-250字。]
            In-depth Analysis: [请用中文对论文的重要性、创新点、潜在影响和局限性进行深入解读与分析，大约200-300字。]
            Keywords: [5-7 relevant keywords for this paper, separated by commas]
            
            PAPER 2:
            Title: ...
            [repeat format for each paper]
            
            EXTREMELY IMPORTANT REQUIREMENTS:
            1. EVERY paper MUST be originally published in English - this is non-negotiable
            2. ALL papers MUST be VERY recent - priority to papers from the past 1-3 months
            3. Focus on papers that specifically address MULTIPLE keywords in combination
            4. Provide Abstract and In-depth Analysis sections in Chinese language ONLY
            5. Ensure each paper has a valid, accessible URL
            6. If possible, favor papers from recognized research institutions and prestigious conferences/journals
            7. Make sure the paper's content is truly relevant to the specified keywords
            
            Remember this is for a "weekly academic report" (学术周报), so papers must be current and cutting-edge to be valuable to readers. Timeliness is extremely important - recent publication dates are crucial.
            `;

            try {
                console.log(`Querying API for combined keywords: "${combinedEnglishKeywords}"`);
                const { content, citations } = await querySonarPro(effectiveApiKey, question);
                
                // Split the content by "PAPER X:" to extract individual papers
                const paperSections = content.split(/PAPER \d+:/g).filter(section => section.trim().length > 0);
                
                if (paperSections.length === 0) {
                    // Try to parse as a single paper if no sections were found
                    const paperInfo = parsePaperInfoFromContent(content, citations, combinedEnglishKeywords, combinedKeywords);
                    if (paperInfo && paperInfo.title && paperInfo.title.trim() !== "标题提取失败" && 
                        paperInfo.title.trim() !== "N/A" && paperInfo.snippet && 
                        paperInfo.snippet.trim() !== "摘要未能提取." && paperInfo.snippet.trim() !== "N/A") {
                        fetchedPapers.push(paperInfo);
                    }
                } else {
                    // Process each paper section
                    for (let i = 0; i < Math.min(paperSections.length, maxPapersToFetch); i++) {
                        const section = paperSections[i];
                        // Use the combined keywords for tracking, but also extract paper-specific keywords
                        const paperInfo = parsePaperInfoFromContent(section, citations, combinedEnglishKeywords, combinedKeywords);
                        
                        if (paperInfo && paperInfo.title && paperInfo.title.trim() !== "标题提取失败" && 
                            paperInfo.title.trim() !== "N/A" && paperInfo.snippet && 
                            paperInfo.snippet.trim() !== "摘要未能提取." && paperInfo.snippet.trim() !== "N/A") {
                            fetchedPapers.push(paperInfo);
                        } else {
                            console.warn(`Could not extract valid paper information from section ${i+1}`);
                        }
                    }
                }
            } catch (error) {
                console.error(`Error processing combined keywords "${combinedEnglishKeywords}":`, error.message);
                fetchedPapers.push({
                    id: `error-card-combined-${Date.now()}`,
                    title: `获取"${combinedKeywords}"相关文献失败`,
                    url: "", authors: ["系统"], affiliations: ["N/A"], journal: "N/A", publicationDate: getBeijingTime().getFullYear() + "年",
                    paperKeywords: [...keywordsToSearch, "错误"],
                    snippet: `未能获取或解析多关键词相关的文献信息。错误: ${error.message.substring(0,100)}...`,
                    interpretation: "请检查浏览器控制台获取更详细的错误信息，或尝试其他关键词组合。"
                });
            }
            
            if (fetchedPapers.length === 0 && keywordsToSearch.length > 0) {
                console.warn("API call did not yield any usable papers after parsing attempts.");
                return [{
                    id: "api-fallback-final-" + Date.now(),
                    title: "未能从API获取具体文献",
                    url: "", authors: ["系统"], affiliations: ["N/A"], journal: "N/A", publicationDate: getBeijingTime().getFullYear() + "年",
                    paperKeywords: keywordsToSearch,
                    snippet: "尝试通过Perplexity API根据您的组合关键词检索文献，但未能成功解析返回结果或未找到匹配文献。请检查您的API密钥、网络连接，或尝试不同的关键词组合。",
                    interpretation: "这可能是由于API响应格式与预期不符，或者当前关键词组合下没有易于提取的文献信息。建议检查控制台日志获取更详细的错误信息。"
                }];
            }

            console.log("Final fetched papers to render:", fetchedPapers);
            return fetchedPapers.slice(0, maxPapersToFetch);
        }
        
        function generateFallbackMockPapers(keywordsToSearch) {
            console.log(`Using FALLBACK mock data generation for keywords: ${keywordsToSearch.join(', ')}`);
            const numPapers = 1 + Math.floor(Math.random() * 2); 
            const fallbackPapers = [];
            const mockSources = [ 
                { 
                    titleBase: "Multi-Agent LLM Framework for 6G Network Slicing (Fallback)", 
                    urlBase: "https://arxiv.org/abs/2304.03442", 
                    authorsBase: ["John Smith", "Emily Chen", "David Wang"], 
                    affiliationsBase: ["University of California; Tech Institute"], 
                    journalBase: "arXiv preprint", 
                    keywordsBase: ["6G", "LLM", "network slicing", "multi-agent systems"], 
                    snippetBase: "这是一篇关于LLM与6G结合的最新研究，探索了如何利用大型语言模型优化下一代通信网络的网络切片技术。研究采用多智能体框架，通过强化学习方法实现自适应资源分配...", 
                    interpretationBase: "该研究的创新点在于首次将大语言模型引入网络切片优化领域，有望解决当前6G网络架构中的资源分配问题。特别是在动态场景下，该框架表现出对网络波动的快速响应能力。不过研究仍处于早期阶段，缺乏大规模实验验证..." 
                },
                { 
                    titleBase: "Semantic Communication Agents for Next-Generation Networks (Fallback)", 
                    urlBase: "https://arxiv.org/abs/2305.05225", 
                    authorsBase: ["Wei Zhang", "Sophia Rodriguez", "Michael Taylor"], 
                    affiliationsBase: ["Stanford University; Communications Research Lab"], 
                    journalBase: "IEEE Communications Magazine", 
                    keywordsBase: ["语义通信", "Agent", "智能网络", "协同计算"], 
                    snippetBase: "本研究探讨了语义通信与智能代理技术的融合前景，提出了一种新型分布式通信框架，能够理解和处理通信内容的语义信息，从而大幅降低传输带宽需求同时提高通信质量...", 
                    interpretationBase: "该研究代表了通信领域的一个重要范式转变，从传统的比特传输转向语义层面的信息交换。特别是在边缘计算场景下，实验表明该方法可减少50%以上的数据传输量。然而，该技术在非结构化数据处理上仍面临挑战..." 
                }
            ];
            for (let i = 0; i < numPapers; i++) {
                const source = mockSources[i % mockSources.length];
                const keyword = keywordsToSearch.length > 0 ? keywordsToSearch[i % keywordsToSearch.length] : "AI";
                const currentYear = getBeijingTime().getFullYear();
                const currentMonth = getBeijingTime().getMonth() + 1;
                const recentMonth = Math.max(1, currentMonth - Math.floor(Math.random() * 3));
                fallbackPapers.push({
                    id: `paper-fallback-${Date.now()}-${i}`,
                    title: source.titleBase,
                    url: source.urlBase, 
                    authors: source.authorsBase, 
                    affiliations: source.affiliationsBase, 
                    journal: source.journalBase,
                    publicationDate: `${currentYear}-${recentMonth.toString().padStart(2, '0')}`,
                    paperKeywords: [...source.keywordsBase, keyword, "Fallback数据"],
                    snippet: `(Fallback数据基于关键词"${keyword}") ${source.snippetBase}`,
                    interpretation: `(Fallback解读) ${source.interpretationBase}`
                });
            }
            return fallbackPapers;
        }


        // --- Report Rendering & Data Persistence ---
        async function renderReport(papersToRender) {
            if (!papersToRender || papersToRender.length === 0) {
                loadingMessage.textContent = '未能获取或生成学术内容。请检查关键词或稍后再试。';
                loadingMessageContainer.style.display = 'flex';
                reportContentDiv.innerHTML = '';
                reportContentDiv.appendChild(loadingMessageContainer);
                paginationContainer.innerHTML = '<span class="pagination-count">0/0</span>';
                localStorage.removeItem(LOCAL_STORAGE_PAPERS_KEY); // Clear stored papers if nothing to render
                updateTimestamps(true); 
                return;
            }
            
            loadingMessageContainer.style.display = 'none'; 
            reportContentDiv.innerHTML = ''; 

            if (intersectionObserver) {
                intersectionObserver.disconnect();
            }

            papersToRender.forEach((item, index) => {
                const card = document.createElement('article');
                card.className = 'report-card-poster';
                card.dataset.index = index; // Add index as data attribute

                let authorsHtml = item.authors.map((author, index) => `${author}<sup class="text-emerald-600">${index + 1}</sup>`).join(', ');
                let affiliationsHtml = item.affiliations.map((aff, index) => `<span class="text-xs block"><sup class="text-emerald-600">${index + 1}</sup>${aff}</span>`).join('');
                let keywordsHtml = item.paperKeywords.map(k => `<span class="poster-keywords-tag">${k}</span>`).join(' ');

                card.innerHTML = `
                    <div class="poster-grid">
                        <div class="poster-left-column">
                            <div>
                                <h3 class="poster-title">${item.title}</h3>
                                <p class="poster-authors">${authorsHtml}</p>
                                <div class="poster-affiliations">${affiliationsHtml}</div>
                            </div>
                            <div class="poster-journal-info mt-auto pt-3 border-t border-slate-300">
                                <p><strong>期刊:</strong> ${item.journal}</p>
                                <p><strong>发表日期:</strong> ${item.publicationDate}</p>
                            </div>
                        </div>
                        <div class="poster-right-column">
                            <section class="mb-3">
                                <h4 class="poster-section-title">摘要</h4>
                                <p class="poster-abstract">${item.snippet}</p>
                            </section>
                            <section class="mb-3">
                                <h4 class="poster-section-title">关键词</h4>
                                <div class="poster-keywords-container flex flex-wrap gap-1 mt-1">
                                    ${keywordsHtml}
                                </div>
                            </section>
                            <section class="mb-4 flex-grow flex flex-col">
                                <h4 class="poster-section-title">深入解读与分析</h4>
                                <div class="poster-interpretation mt-1 flex-grow overflow-y-auto">
                                    <p class="poster-interpretation-content">${item.interpretation || "暂无深入解读。"}</p>
                                </div>
                            </section>
                            <footer class="mt-auto pt-3">
                                ${item.url && item.url !== "#" ? 
                                `<a href="${item.url}" target="_blank" rel="noopener noreferrer" class="poster-read-more-btn">
                                    阅读原文 &rarr;
                                </a>` : 
                                `<button class="poster-read-more-btn bg-gray-400 cursor-not-allowed" disabled>
                                    暂无原文链接
                                </button>`}
                            </footer>
                        </div>
                    </div>
                `;
                reportContentDiv.appendChild(card);
            });

            // Generate pagination dots
            renderPaginationDots(papersToRender.length);

            try {
                localStorage.setItem(LOCAL_STORAGE_PAPERS_KEY, JSON.stringify(papersToRender));
                localStorage.setItem(LOCAL_STORAGE_LAST_FETCH_KEY, getBeijingTime().toISOString());
                console.log("Papers saved to localStorage.");
                
                // If GitHub storage is enabled, save data there too
                if (USE_GITHUB_STORAGE) {
                    await saveSharedData(papersToRender);
                }
            } catch (e) {
                console.error("Error saving papers to localStorage:", e);
            }


            setupIntersectionObserver();
            const firstCard = reportContentDiv.querySelector('.report-card-poster');
            if (firstCard) {
                setTimeout(() => {
                     if (reportContentDiv.contains(firstCard)) { 
                        firstCard.classList.add('is-active');
                     }
                },100);
            }
            updateTimestamps(true); 
        }

        function setupIntersectionObserver() {
            const cards = document.querySelectorAll('.report-card-poster');
            if (cards.length === 0) return;

            const options = {
                root: reportContentDiv, 
                rootMargin: '0px', 
                threshold: 0.6 
            };

            intersectionObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        cards.forEach(c => c.classList.remove('is-active'));
                        entry.target.classList.add('is-active');
                        
                        // Update pagination dots and counter if they exist
                        const currentIndex = Array.from(cards).indexOf(entry.target);
                        const dots = document.querySelectorAll('.pagination-dot');
                        if (dots.length > 0) {
                            dots.forEach(dot => dot.classList.remove('active'));
                            if (dots[currentIndex]) {
                                dots[currentIndex].classList.add('active');
                            }
                            
                            // Update counter
                            const countIndicator = document.getElementById('pagination-count');
                            if (countIndicator) {
                                countIndicator.textContent = `${currentIndex + 1}/${cards.length}`;
                            }
                        }
                    }
                });
            }, options);

            cards.forEach(card => {
                intersectionObserver.observe(card);
            });
        }
        
        function updateTimestamps(contentFetchedSuccessfully = false) {
            const now = getBeijingTime();
            if (contentFetchedSuccessfully) { 
                lastUpdatedTimeSpan.textContent = getFormattedDateTime(now);
            } else { 
                const lastFetchISO = localStorage.getItem(LOCAL_STORAGE_LAST_FETCH_KEY);
                if (lastFetchISO) {
                    lastUpdatedTimeSpan.textContent = getFormattedDateTime(new Date(lastFetchISO));
                } else {
                    lastUpdatedTimeSpan.textContent = "从未获取";
                }
            }
            reportDateSpan.textContent = `报告生成于: ${getFormattedDateTime(now)}`; 
            
            // 计算下次更新时间（考虑工作日）
            let nextUpdate = new Date(now);
            const currentDay = now.getDay(); // 0是周日，1-5是周一至周五，6是周六
            const currentHour = now.getHours();
            
            if (currentDay === 0) { // 周日
                // 设置为下周一早上8点
                nextUpdate.setDate(now.getDate() + 1);
                nextUpdate.setHours(8, 0, 0, 0);
            } else if (currentDay === 6) { // 周六
                // 设置为下周一早上8点
                nextUpdate.setDate(now.getDate() + 2);
                nextUpdate.setHours(8, 0, 0, 0);
            } else if (currentDay >= 1 && currentDay <= 5) { // 周一至周五
                if (currentHour >= 8) {
                    // 已过当天8点，如果是周五，设为下周一，否则设为明天
                    if (currentDay === 5) { // 周五
                        nextUpdate.setDate(now.getDate() + 3); // 跳到下周一
                    } else {
                        nextUpdate.setDate(now.getDate() + 1); // 明天
                    }
                }
                nextUpdate.setHours(8, 0, 0, 0);
            }
            
            nextUpdateTimeSpan.textContent = getFormattedDateTime(nextUpdate);
        }

        async function loadOrFetchPapers(forceApiFetch = false) {
            // Try to load from GitHub first if enabled
            if (USE_GITHUB_STORAGE && !forceApiFetch) {
                console.log("Attempting to load data from GitHub...");
                const githubData = await loadSharedData();
                if (githubData && githubData.papers && githubData.papers.length > 0) {
                    console.log("Successfully loaded papers from GitHub");
                    return; // renderReport is called inside loadSharedData
                }
                console.log("No valid data from GitHub, falling back to local storage or API");
            }
            
            if (!forceApiFetch) {
                const storedPapersJSON = localStorage.getItem(LOCAL_STORAGE_PAPERS_KEY);
                if (storedPapersJSON) {
                    try {
                        const storedPapers = JSON.parse(storedPapersJSON);
                        if (storedPapers && storedPapers.length > 0) {
                            console.log("Loading papers from localStorage.");
                            await renderReport(storedPapers);
                            updateTimestamps(false); 
                            return; 
                        }
                    } catch (e) {
                        console.error("Error parsing stored papers, will fetch from API:", e);
                        localStorage.removeItem(LOCAL_STORAGE_PAPERS_KEY); 
                    }
                }
            }

            console.log(forceApiFetch ? "Forcing API fetch." : "No valid cached papers, fetching from API.");
            try {
                const papers = await fetchPapersFromAPI(activeKeywords);
                if (papers && papers.length > 0) {
                    await renderReport(papers); 
                } else {
                    console.log("API returned no usable papers, rendering empty or fallback.");
                    await renderReport([]); 
                }
            } catch (error) {
                console.error("Critical error in loadOrFetchPapers (API fetch part):", error);
                loadingMessage.textContent = `获取内容时发生严重错误: ${error.message}.`;
                loadingMessageContainer.style.display = 'flex';
                reportContentDiv.innerHTML = '';
                reportContentDiv.appendChild(loadingMessageContainer);
                await renderReport(generateFallbackMockPapers(activeKeywords)); 
            }
        }


        async function checkForAutoUpdate() {
            const now = getBeijingTime();
            const lastAutoUpdateDate = localStorage.getItem(LOCAL_STORAGE_LAST_AUTO_UPDATE_DATE_KEY);
            const todayStr = now.toLocaleDateString('zh-CN', {timeZone: 'Asia/Shanghai'});
            const dayOfWeek = now.getDay(); // 0是周日，1-5是周一至周五，6是周六
            
            // 只在工作日（周一至周五）检查更新
            const isWorkday = dayOfWeek >= 1 && dayOfWeek <= 5;
            
            if (isWorkday && now.getHours() === 8 && now.getMinutes() === 0) { 
                if (lastAutoUpdateDate !== todayStr) {
                    console.log("Performing automatic update at 8:00 AM Beijing Time on a workday.");
                    await loadOrFetchPapers(true); 
                    localStorage.setItem(LOCAL_STORAGE_LAST_AUTO_UPDATE_DATE_KEY, todayStr);
                    
                    // If using GitHub storage, update shared data
                    if (USE_GITHUB_STORAGE) {
                        const papersData = JSON.parse(localStorage.getItem(LOCAL_STORAGE_PAPERS_KEY) || '[]');
                        await saveSharedData(papersData);
                    }
                } else {
                    console.log("Automatic update for today already performed.");
                }
            }
        }

        function startAutoUpdateScheduler() {
            checkForAutoUpdate(); 
            if (autoUpdateInterval) clearInterval(autoUpdateInterval); 
            autoUpdateInterval = setInterval(checkForAutoUpdate, 60000); 
        }


        // --- Event Listeners ---
        addKeywordForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            await addActiveKeyword(keywordInput.value); 
        });

        manualRefreshButton.addEventListener('click', async () => {
            console.log("Manual refresh triggered.");
            
            // 如果不在调试模式下，并且没有API密钥，则显示安全提示
            if (!isDebugMode && (!PERPLEXITY_API_KEY || PERPLEXITY_API_KEY === "")) {
                console.log("Manual refresh only works in debug mode or when API key is configured");
                loadingMessage.textContent = `出于安全考虑，在生产环境中不支持手动API刷新。此功能仅在自动更新或调试模式下可用。`;
                loadingMessageContainer.style.display = 'flex';
                reportContentDiv.innerHTML = ''; 
                reportContentDiv.appendChild(loadingMessageContainer);
                
                // 显示最近的缓存数据
                setTimeout(async () => {
                    const storedPapersJSON = localStorage.getItem(LOCAL_STORAGE_PAPERS_KEY);
                    if (storedPapersJSON) {
                        try {
                            const storedPapers = JSON.parse(storedPapersJSON);
                            if (storedPapers && storedPapers.length > 0) {
                                console.log("Displaying cached papers instead");
                                await renderReport(storedPapers);
                            }
                        } catch (e) {
                            console.error("Error parsing stored papers:", e);
                        }
                    }
                }, 3000);
                return;
            }
            
            // 在调试模式或有API密钥的情况下继续刷新
            try {
                loadingMessage.textContent = `正在通过API获取最新论文...`;
                loadingMessageContainer.style.display = 'flex';
                reportContentDiv.innerHTML = ''; 
                reportContentDiv.appendChild(loadingMessageContainer);
                
                // 直接调用API，绕过缓存检查
                const papers = await fetchPapersFromAPI(activeKeywords);
                if (papers && papers.length > 0) {
                    await renderReport(papers);
                } else {
                    console.log("API returned no usable papers, rendering empty or fallback.");
                    await renderReport([]);
                }
            } catch (error) {
                console.error("Error during manual refresh:", error);
                loadingMessage.textContent = `获取内容时发生错误: ${error.message}`;
                loadingMessageContainer.style.display = 'flex';
            }
            keywordsModified = false; // 重置关键词修改状态
        });

        // --- Initialization ---
        async function initializeApp() {
            currentYearSpan.textContent = new Date().getFullYear();
            
            // 检查是否有保存的开发者设置
            const savedApiKey = localStorage.getItem('dev_api_key');
            if (savedApiKey) {
                window.tempApiKey = savedApiKey;
                console.log("Loaded saved development API key");
            }
            
            // GitHub configuration message
            if (!USE_GITHUB_STORAGE) {
                console.log("GitHub storage is disabled. To enable shared data persistence:");
                console.log("1. Set your GitHub username and repo name in the code");
                console.log("2. Create a GitHub personal access token with repo scope");
                console.log("3. Set USE_GITHUB_STORAGE to true");
            }
            
            // Try to load from GitHub first if enabled
            if (USE_GITHUB_STORAGE) {
                console.log("GitHub storage is enabled, attempting to load shared data...");
                const githubData = await loadSharedData();
                if (githubData) {
                    console.log("Successfully loaded shared data from GitHub");
                    return; // Keywords and papers are loaded in loadSharedData
                }
                console.log("No data found on GitHub or error occurred, falling back to local mode");
            }
            
            // Fall back to localStorage if GitHub fails or is disabled
            loadActiveKeywordsFromLocalStorage(); 
            keywordsModified = false; // 初始化时重置关键词修改状态
            renderActiveKeywords();
            await loadOrFetchPapers(false); 
            startAutoUpdateScheduler(); 
        }

        document.addEventListener('DOMContentLoaded', initializeApp);

        // --- 开发者工具栏逻辑 ---
        // 快捷键打开开发者工具栏: Ctrl+Shift+D
        document.addEventListener('keydown', (e) => {
            // 检查是否是Ctrl+Shift+D (或Mac上的Command+Shift+D)
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'd') {
                e.preventDefault();
                devToolbar.classList.toggle('hidden');
                
                // 加载已保存的设置
                const savedApiKey = localStorage.getItem('dev_api_key') || '';
                if (savedApiKey) {
                    devApiKeyInput.value = savedApiKey;
                }
                
                devDebugModeToggle.checked = isDebugMode;
            }
        });

        // 关闭按钮
        closeDevToolbarBtn.addEventListener('click', () => {
            devToolbar.classList.add('hidden');
        });

        // 应用开发者设置
        applyDevSettingsBtn.addEventListener('click', () => {
            const apiKey = devApiKeyInput.value.trim();
            
            if (apiKey) {
                localStorage.setItem('dev_api_key', apiKey);
                // 临时覆盖API密钥
                window.tempApiKey = apiKey;
                console.log("API key saved locally for development");
            } else {
                localStorage.removeItem('dev_api_key');
                window.tempApiKey = null;
            }
            
            isDebugMode = devDebugModeToggle.checked;
            console.log("Debug mode:", isDebugMode ? "ON" : "OFF");
            
            // 隐藏工具栏
            devToolbar.classList.add('hidden');
            
            // 如果刚启用了调试模式，提示用户
            if (isDebugMode) {
                alert("调试模式已启用。现在可以使用手动刷新功能。");
            }
        });

        // Add new function to render pagination dots
        function renderPaginationDots(totalCount) {
            const dotsContainer = document.getElementById('dots-container');
            dotsContainer.innerHTML = '';
            
            // Update count indicator
            const countIndicator = document.getElementById('pagination-count');
            countIndicator.textContent = totalCount > 0 ? `1/${totalCount}` : '0/0';
            
            // Add dots
            for (let i = 0; i < totalCount; i++) {
                const dot = document.createElement('div');
                dot.className = 'pagination-dot';
                dot.dataset.index = i;
                dot.addEventListener('click', () => {
                    navigateToCard(i);
                });
                dotsContainer.appendChild(dot);
            }
            
            // Activate first dot if exists
            if (totalCount > 0) {
                dotsContainer.querySelector('.pagination-dot').classList.add('active');
            }
        }

        // Function to navigate to a specific card
        function navigateToCard(index) {
            const cards = reportContentDiv.querySelectorAll('.report-card-poster');
            if (index >= 0 && index < cards.length) {
                cards[index].scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'nearest', 
                    inline: 'center' 
                });
            }
        }
    </script>
</body>
</html>
